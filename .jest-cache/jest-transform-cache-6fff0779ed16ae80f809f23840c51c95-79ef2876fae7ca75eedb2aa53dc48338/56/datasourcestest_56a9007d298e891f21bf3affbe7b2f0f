63782b3c64965629aacfe7fc1d648612
/**
 * Data Sources API Service Tests
 * Testing data source CRUD operations and analytics queries
 */ "use strict";
// Mock the API client
jest.mock('../index', ()=>({
        apiClient: {
            get: jest.fn(),
            post: jest.fn(),
            put: jest.fn(),
            delete: jest.fn()
        },
        createQueryFunction: (fn)=>async ()=>{
                const response = await fn();
                if (!response.success) {
                    throw new Error(response.message || 'API request failed');
                }
                return response.data;
            }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _datasources = require("../data-sources");
const _index = require("../index");
describe('DataSourceService', ()=>{
    const mockApiClient = _index.apiClient;
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('getDataSources', ()=>{
        const mockDataSources = [
            {
                id: 'ds-1',
                name: 'Google Analytics',
                type: 'google_analytics',
                status: 'connected',
                organizationId: 'org-1',
                workspaceId: 'ws-1',
                lastSync: '2024-01-15T10:00:00Z',
                config: {
                    accountId: '12345',
                    propertyId: '67890',
                    viewId: '11111'
                }
            },
            {
                id: 'ds-2',
                name: 'Analytics API',
                type: 'rest_api',
                status: 'connected',
                organizationId: 'org-1',
                workspaceId: 'ws-1',
                lastSync: '2024-01-20T10:00:00Z',
                config: {
                    baseUrl: 'https://api.analytics.com',
                    authType: 'bearer'
                }
            }
        ];
        it('should get all data sources without workspace filter', async ()=>{
            const mockResponse = {
                data: mockDataSources,
                success: true
            };
            mockApiClient.get.mockResolvedValueOnce(mockResponse);
            const result = await _datasources.DataSourceService.getDataSources();
            expect(mockApiClient.get).toHaveBeenCalledWith('/data-sources');
            expect(result).toEqual(mockDataSources);
        });
        it('should get data sources filtered by workspace', async ()=>{
            const mockResponse = {
                data: [
                    mockDataSources[0]
                ],
                success: true
            };
            mockApiClient.get.mockResolvedValueOnce(mockResponse);
            const result = await _datasources.DataSourceService.getDataSources('ws-1');
            expect(mockApiClient.get).toHaveBeenCalledWith('/data-sources?workspaceId=ws-1');
            expect(result).toHaveLength(1);
            expect(result[0].workspaceId).toBe('ws-1');
        });
        it('should handle empty data sources', async ()=>{
            const mockResponse = {
                data: [],
                success: true
            };
            mockApiClient.get.mockResolvedValueOnce(mockResponse);
            const result = await _datasources.DataSourceService.getDataSources();
            expect(result).toEqual([]);
        });
        it('should handle API errors', async ()=>{
            mockApiClient.get.mockRejectedValueOnce(new Error('Network error'));
            await expect(_datasources.DataSourceService.getDataSources()).rejects.toThrow('Network error');
        });
    });
    describe('getDataSource', ()=>{
        const mockDataSource = {
            id: 'ds-1',
            name: 'Production Database',
            type: 'rest_api',
            status: 'connected',
            organizationId: 'org-1',
            workspaceId: 'ws-1',
            config: {
                baseUrl: 'https://db.example.com',
                authType: 'bearer'
            }
        };
        it('should get single data source by ID', async ()=>{
            const mockResponse = {
                data: mockDataSource,
                success: true
            };
            mockApiClient.get.mockResolvedValueOnce(mockResponse);
            const result = await _datasources.DataSourceService.getDataSource('ds-1');
            expect(mockApiClient.get).toHaveBeenCalledWith('/data-sources/ds-1');
            expect(result).toEqual(mockDataSource);
        });
        it('should handle not found error', async ()=>{
            mockApiClient.get.mockRejectedValueOnce(new Error('Data source not found'));
            await expect(_datasources.DataSourceService.getDataSource('non-existent')).rejects.toThrow('Data source not found');
        });
    });
    describe('createDataSource', ()=>{
        const createRequest = {
            name: 'New Data Source',
            type: 'rest_api',
            config: {
                baseUrl: 'https://localhost:3306',
                authType: 'bearer'
            },
            workspaceId: 'ws-1'
        };
        const mockCreatedDataSource = {
            id: 'ds-new',
            ...createRequest,
            organizationId: 'org-1',
            status: 'connected'
        };
        it('should create new data source', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: true,
                data: mockCreatedDataSource
            });
            const result = await _datasources.DataSourceService.createDataSource(createRequest);
            expect(mockApiClient.post).toHaveBeenCalledWith('/data-sources', createRequest);
            expect(result).toEqual(mockCreatedDataSource);
        });
        it('should handle creation failure', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: false,
                message: 'Invalid configuration'
            });
            await expect(_datasources.DataSourceService.createDataSource(createRequest)).rejects.toThrow('Invalid configuration');
        });
        it('should handle generic creation error', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: false
            });
            await expect(_datasources.DataSourceService.createDataSource(createRequest)).rejects.toThrow('Failed to create data source');
        });
        it('should create data source without workspace', async ()=>{
            const requestWithoutWorkspace = {
                name: 'Global Data Source',
                type: 'rest_api',
                config: {
                    baseUrl: 'https://api.example.com',
                    authType: 'none'
                }
            };
            mockApiClient.post.mockResolvedValueOnce({
                success: true,
                data: {
                    id: 'ds-global',
                    ...requestWithoutWorkspace,
                    organizationId: 'org-1',
                    status: 'connected'
                }
            });
            const result = await _datasources.DataSourceService.createDataSource(requestWithoutWorkspace);
            expect(result.workspaceId).toBeUndefined();
        });
    });
    describe('updateDataSource', ()=>{
        const updateRequest = {
            name: 'Updated Database',
            config: {
                baseUrl: 'https://new-db.example.com'
            }
        };
        const mockUpdatedDataSource = {
            id: 'ds-1',
            name: 'Updated Database',
            type: 'rest_api',
            status: 'connected',
            organizationId: 'org-1',
            workspaceId: 'ws-1',
            config: {
                baseUrl: 'https://new-db.example.com',
                authType: 'bearer'
            }
        };
        it('should update data source', async ()=>{
            mockApiClient.put.mockResolvedValueOnce({
                success: true,
                data: mockUpdatedDataSource
            });
            const result = await _datasources.DataSourceService.updateDataSource('ds-1', updateRequest);
            expect(mockApiClient.put).toHaveBeenCalledWith('/data-sources/ds-1', updateRequest);
            expect(result).toEqual(mockUpdatedDataSource);
        });
        it('should update only name', async ()=>{
            const nameOnlyUpdate = {
                name: 'Renamed Database'
            };
            mockApiClient.put.mockResolvedValueOnce({
                success: true,
                data: {
                    ...mockUpdatedDataSource,
                    name: 'Renamed Database'
                }
            });
            const result = await _datasources.DataSourceService.updateDataSource('ds-1', nameOnlyUpdate);
            expect(mockApiClient.put).toHaveBeenCalledWith('/data-sources/ds-1', nameOnlyUpdate);
            expect(result.name).toBe('Renamed Database');
        });
        it('should handle update failure', async ()=>{
            mockApiClient.put.mockResolvedValueOnce({
                success: false,
                message: 'Connection failed with new config'
            });
            await expect(_datasources.DataSourceService.updateDataSource('ds-1', updateRequest)).rejects.toThrow('Connection failed with new config');
        });
    });
    describe('deleteDataSource', ()=>{
        it('should delete data source', async ()=>{
            mockApiClient.delete.mockResolvedValueOnce({
                success: true
            });
            await expect(_datasources.DataSourceService.deleteDataSource('ds-1')).resolves.not.toThrow();
            expect(mockApiClient.delete).toHaveBeenCalledWith('/data-sources/ds-1');
        });
        it('should handle delete error', async ()=>{
            mockApiClient.delete.mockRejectedValueOnce(new Error('Cannot delete active data source'));
            await expect(_datasources.DataSourceService.deleteDataSource('ds-1')).rejects.toThrow('Cannot delete active data source');
        });
    });
    describe('testConnection', ()=>{
        it('should test successful connection', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: true,
                data: {
                    connected: true
                }
            });
            const result = await _datasources.DataSourceService.testConnection('ds-1');
            expect(mockApiClient.post).toHaveBeenCalledWith('/data-sources/ds-1/test');
            expect(result).toEqual({
                connected: true
            });
        });
        it('should test failed connection', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: true,
                data: {
                    connected: false,
                    error: 'ECONNREFUSED'
                }
            });
            const result = await _datasources.DataSourceService.testConnection('ds-1');
            expect(result).toEqual({
                connected: false,
                error: 'ECONNREFUSED'
            });
        });
        it('should handle test API error', async ()=>{
            mockApiClient.post.mockRejectedValueOnce(new Error('API error'));
            await expect(_datasources.DataSourceService.testConnection('ds-1')).rejects.toThrow('API error');
        });
    });
    describe('AnalyticsService.query', ()=>{
        const mockQuery = {
            dataSource: 'ds-1',
            metrics: [
                'users',
                'sessions'
            ],
            dimensions: [
                'country',
                'device'
            ],
            timeRange: {
                start: '2024-01-01',
                end: '2024-01-31',
                preset: 'last30days'
            }
        };
        const mockResponse = {
            success: true,
            data: {
                data: [
                    {
                        dimensions: {
                            country: 'US',
                            device: 'desktop'
                        },
                        metrics: {
                            users: 1000,
                            sessions: 1500
                        },
                        timestamp: '2024-01-01'
                    },
                    {
                        dimensions: {
                            country: 'DE',
                            device: 'mobile'
                        },
                        metrics: {
                            users: 800,
                            sessions: 1200
                        },
                        timestamp: '2024-01-02'
                    }
                ],
                totalRows: 2,
                query: mockQuery,
                executionTime: 45,
                cached: false
            }
        };
        it('should execute query successfully', async ()=>{
            mockApiClient.post.mockResolvedValueOnce(mockResponse);
            const result = await _datasources.AnalyticsService.query(mockQuery);
            expect(mockApiClient.post).toHaveBeenCalledWith('/analytics/query', mockQuery);
            expect(result).toEqual(mockResponse.data);
        });
        it('should execute query with filters', async ()=>{
            const queryWithFilters = {
                ...mockQuery,
                filters: [
                    {
                        field: 'country',
                        operator: 'equals',
                        value: 'US'
                    }
                ]
            };
            mockApiClient.post.mockResolvedValueOnce(mockResponse);
            await _datasources.AnalyticsService.query(queryWithFilters);
            expect(mockApiClient.post).toHaveBeenCalledWith('/analytics/query', queryWithFilters);
        });
        it('should handle query execution error', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: false,
                message: 'Syntax error in SQL query'
            });
            await expect(_datasources.AnalyticsService.query(mockQuery)).rejects.toThrow('Syntax error in SQL query');
        });
        it('should handle empty query results', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: true,
                data: {
                    data: [],
                    totalRows: 0,
                    query: mockQuery,
                    executionTime: 10,
                    cached: false
                }
            });
            const result = await _datasources.AnalyticsService.query(mockQuery);
            expect(result.data).toHaveLength(0);
            expect(result.totalRows).toBe(0);
        });
    });
    describe('getAvailableMetrics and getAvailableDimensions', ()=>{
        const mockMetrics = [
            'revenue',
            'users',
            'sessions',
            'pageviews'
        ];
        const mockDimensions = [
            'country',
            'device',
            'browser',
            'page'
        ];
        it('should get available metrics', async ()=>{
            const mockResponse = {
                data: mockMetrics,
                success: true
            };
            mockApiClient.get.mockResolvedValueOnce(mockResponse);
            const result = await _datasources.DataSourceService.getAvailableMetrics('ds-1');
            expect(mockApiClient.get).toHaveBeenCalledWith('/data-sources/ds-1/metrics');
            expect(result).toEqual(mockMetrics);
        });
        it('should get available dimensions', async ()=>{
            const mockResponse = {
                data: mockDimensions,
                success: true
            };
            mockApiClient.get.mockResolvedValueOnce(mockResponse);
            const result = await _datasources.DataSourceService.getAvailableDimensions('ds-1');
            expect(mockApiClient.get).toHaveBeenCalledWith('/data-sources/ds-1/dimensions');
            expect(result).toEqual(mockDimensions);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy96d2VpZ2VuL1NpdGVzL2RhdGVuLXNlZS12Mi9zcmMvbGliL2FwaS9fX3Rlc3RzX18vZGF0YS1zb3VyY2VzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEYXRhIFNvdXJjZXMgQVBJIFNlcnZpY2UgVGVzdHNcbiAqIFRlc3RpbmcgZGF0YSBzb3VyY2UgQ1JVRCBvcGVyYXRpb25zIGFuZCBhbmFseXRpY3MgcXVlcmllc1xuICovXG5cbmltcG9ydCB0eXBlIHsgRGF0YVNvdXJjZSwgRGF0YVNvdXJjZVR5cGUsIEFuYWx5dGljc1F1ZXJ5IH0gZnJvbSAnQC90eXBlcyc7XG5cbmltcG9ydCB7IERhdGFTb3VyY2VTZXJ2aWNlLCBBbmFseXRpY3NTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0YS1zb3VyY2VzJztcbmltcG9ydCB7IGFwaUNsaWVudCB9IGZyb20gJy4uL2luZGV4JztcblxuLy8gTW9jayB0aGUgQVBJIGNsaWVudFxuamVzdC5tb2NrKCcuLi9pbmRleCcsICgpID0+ICh7XG4gIGFwaUNsaWVudDoge1xuICAgIGdldDogamVzdC5mbigpLFxuICAgIHBvc3Q6IGplc3QuZm4oKSxcbiAgICBwdXQ6IGplc3QuZm4oKSxcbiAgICBkZWxldGU6IGplc3QuZm4oKSxcbiAgfSxcbiAgY3JlYXRlUXVlcnlGdW5jdGlvbjogKGZuOiBGdW5jdGlvbikgPT4gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZm4oKTtcbiAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5tZXNzYWdlIHx8ICdBUEkgcmVxdWVzdCBmYWlsZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG59KSk7XG5cbmRlc2NyaWJlKCdEYXRhU291cmNlU2VydmljZScsICgpID0+IHtcbiAgY29uc3QgbW9ja0FwaUNsaWVudCA9IGFwaUNsaWVudCBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgYXBpQ2xpZW50PjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldERhdGFTb3VyY2VzJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tEYXRhU291cmNlczogRGF0YVNvdXJjZVtdID0gW1xuICAgICAge1xuICAgICAgICBpZDogJ2RzLTEnLFxuICAgICAgICBuYW1lOiAnR29vZ2xlIEFuYWx5dGljcycsXG4gICAgICAgIHR5cGU6ICdnb29nbGVfYW5hbHl0aWNzJyxcbiAgICAgICAgc3RhdHVzOiAnY29ubmVjdGVkJyxcbiAgICAgICAgb3JnYW5pemF0aW9uSWQ6ICdvcmctMScsXG4gICAgICAgIHdvcmtzcGFjZUlkOiAnd3MtMScsXG4gICAgICAgIGxhc3RTeW5jOiAnMjAyNC0wMS0xNVQxMDowMDowMFonLFxuICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICBhY2NvdW50SWQ6ICcxMjM0NScsXG4gICAgICAgICAgcHJvcGVydHlJZDogJzY3ODkwJyxcbiAgICAgICAgICB2aWV3SWQ6ICcxMTExMScsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJ2RzLTInLFxuICAgICAgICBuYW1lOiAnQW5hbHl0aWNzIEFQSScsXG4gICAgICAgIHR5cGU6ICdyZXN0X2FwaScsXG4gICAgICAgIHN0YXR1czogJ2Nvbm5lY3RlZCcsXG4gICAgICAgIG9yZ2FuaXphdGlvbklkOiAnb3JnLTEnLFxuICAgICAgICB3b3Jrc3BhY2VJZDogJ3dzLTEnLFxuICAgICAgICBsYXN0U3luYzogJzIwMjQtMDEtMjBUMTA6MDA6MDBaJyxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgYmFzZVVybDogJ2h0dHBzOi8vYXBpLmFuYWx5dGljcy5jb20nLFxuICAgICAgICAgIGF1dGhUeXBlOiAnYmVhcmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGl0KCdzaG91bGQgZ2V0IGFsbCBkYXRhIHNvdXJjZXMgd2l0aG91dCB3b3Jrc3BhY2UgZmlsdGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiBtb2NrRGF0YVNvdXJjZXMsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB9O1xuICAgICAgbW9ja0FwaUNsaWVudC5nZXQubW9ja1Jlc29sdmVkVmFsdWVPbmNlKG1vY2tSZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IERhdGFTb3VyY2VTZXJ2aWNlLmdldERhdGFTb3VyY2VzKCk7XG5cbiAgICAgIGV4cGVjdChtb2NrQXBpQ2xpZW50LmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9kYXRhLXNvdXJjZXMnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja0RhdGFTb3VyY2VzKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZ2V0IGRhdGEgc291cmNlcyBmaWx0ZXJlZCBieSB3b3Jrc3BhY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IFttb2NrRGF0YVNvdXJjZXNbMF1dLFxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIG1vY2tBcGlDbGllbnQuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZShtb2NrUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBEYXRhU291cmNlU2VydmljZS5nZXREYXRhU291cmNlcygnd3MtMScpO1xuXG4gICAgICBleHBlY3QobW9ja0FwaUNsaWVudC5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvZGF0YS1zb3VyY2VzP3dvcmtzcGFjZUlkPXdzLTEnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHRbMF0ud29ya3NwYWNlSWQpLnRvQmUoJ3dzLTEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IGRhdGEgc291cmNlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB9O1xuICAgICAgbW9ja0FwaUNsaWVudC5nZXQubW9ja1Jlc29sdmVkVmFsdWVPbmNlKG1vY2tSZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IERhdGFTb3VyY2VTZXJ2aWNlLmdldERhdGFTb3VyY2VzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgQVBJIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBcGlDbGllbnQuZ2V0Lm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ05ldHdvcmsgZXJyb3InKSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChEYXRhU291cmNlU2VydmljZS5nZXREYXRhU291cmNlcygpKS5yZWplY3RzLnRvVGhyb3coJ05ldHdvcmsgZXJyb3InKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldERhdGFTb3VyY2UnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0RhdGFTb3VyY2U6IERhdGFTb3VyY2UgPSB7XG4gICAgICBpZDogJ2RzLTEnLFxuICAgICAgbmFtZTogJ1Byb2R1Y3Rpb24gRGF0YWJhc2UnLFxuICAgICAgdHlwZTogJ3Jlc3RfYXBpJyxcbiAgICAgIHN0YXR1czogJ2Nvbm5lY3RlZCcsXG4gICAgICBvcmdhbml6YXRpb25JZDogJ29yZy0xJyxcbiAgICAgIHdvcmtzcGFjZUlkOiAnd3MtMScsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgYmFzZVVybDogJ2h0dHBzOi8vZGIuZXhhbXBsZS5jb20nLFxuICAgICAgICBhdXRoVHlwZTogJ2JlYXJlcicsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIGdldCBzaW5nbGUgZGF0YSBzb3VyY2UgYnkgSUQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IG1vY2tEYXRhU291cmNlLFxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIG1vY2tBcGlDbGllbnQuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZShtb2NrUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBEYXRhU291cmNlU2VydmljZS5nZXREYXRhU291cmNlKCdkcy0xJyk7XG5cbiAgICAgIGV4cGVjdChtb2NrQXBpQ2xpZW50LmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9kYXRhLXNvdXJjZXMvZHMtMScpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrRGF0YVNvdXJjZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBub3QgZm91bmQgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LmdldC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdEYXRhIHNvdXJjZSBub3QgZm91bmQnKSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChEYXRhU291cmNlU2VydmljZS5nZXREYXRhU291cmNlKCdub24tZXhpc3RlbnQnKSkucmVqZWN0cy50b1Rocm93KCdEYXRhIHNvdXJjZSBub3QgZm91bmQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NyZWF0ZURhdGFTb3VyY2UnLCAoKSA9PiB7XG4gICAgY29uc3QgY3JlYXRlUmVxdWVzdCA9IHtcbiAgICAgIG5hbWU6ICdOZXcgRGF0YSBTb3VyY2UnLFxuICAgICAgdHlwZTogJ3Jlc3RfYXBpJyBhcyBEYXRhU291cmNlVHlwZSxcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBiYXNlVXJsOiAnaHR0cHM6Ly9sb2NhbGhvc3Q6MzMwNicsXG4gICAgICAgIGF1dGhUeXBlOiAnYmVhcmVyJyBhcyBjb25zdCxcbiAgICAgIH0sXG4gICAgICB3b3Jrc3BhY2VJZDogJ3dzLTEnLFxuICAgIH07XG5cbiAgICBjb25zdCBtb2NrQ3JlYXRlZERhdGFTb3VyY2U6IERhdGFTb3VyY2UgPSB7XG4gICAgICBpZDogJ2RzLW5ldycsXG4gICAgICAuLi5jcmVhdGVSZXF1ZXN0LFxuICAgICAgb3JnYW5pemF0aW9uSWQ6ICdvcmctMScsXG4gICAgICBzdGF0dXM6ICdjb25uZWN0ZWQnLFxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBuZXcgZGF0YSBzb3VyY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogbW9ja0NyZWF0ZWREYXRhU291cmNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IERhdGFTb3VyY2VTZXJ2aWNlLmNyZWF0ZURhdGFTb3VyY2UoY3JlYXRlUmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChtb2NrQXBpQ2xpZW50LnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvZGF0YS1zb3VyY2VzJywgY3JlYXRlUmVxdWVzdCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tDcmVhdGVkRGF0YVNvdXJjZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjcmVhdGlvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0FwaUNsaWVudC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBjb25maWd1cmF0aW9uJyxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QoRGF0YVNvdXJjZVNlcnZpY2UuY3JlYXRlRGF0YVNvdXJjZShjcmVhdGVSZXF1ZXN0KSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnSW52YWxpZCBjb25maWd1cmF0aW9uJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBnZW5lcmljIGNyZWF0aW9uIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0FwaUNsaWVudC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChEYXRhU291cmNlU2VydmljZS5jcmVhdGVEYXRhU291cmNlKGNyZWF0ZVJlcXVlc3QpKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdGYWlsZWQgdG8gY3JlYXRlIGRhdGEgc291cmNlJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBkYXRhIHNvdXJjZSB3aXRob3V0IHdvcmtzcGFjZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RXaXRob3V0V29ya3NwYWNlID0ge1xuICAgICAgICBuYW1lOiAnR2xvYmFsIERhdGEgU291cmNlJyxcbiAgICAgICAgdHlwZTogJ3Jlc3RfYXBpJyBhcyBEYXRhU291cmNlVHlwZSxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgYmFzZVVybDogJ2h0dHBzOi8vYXBpLmV4YW1wbGUuY29tJyxcbiAgICAgICAgICBhdXRoVHlwZTogJ25vbmUnIGFzIGNvbnN0LFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgbW9ja0FwaUNsaWVudC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogJ2RzLWdsb2JhbCcsXG4gICAgICAgICAgLi4ucmVxdWVzdFdpdGhvdXRXb3Jrc3BhY2UsXG4gICAgICAgICAgb3JnYW5pemF0aW9uSWQ6ICdvcmctMScsXG4gICAgICAgICAgc3RhdHVzOiAnY29ubmVjdGVkJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBEYXRhU291cmNlU2VydmljZS5jcmVhdGVEYXRhU291cmNlKHJlcXVlc3RXaXRob3V0V29ya3NwYWNlKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC53b3Jrc3BhY2VJZCkudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndXBkYXRlRGF0YVNvdXJjZScsICgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVSZXF1ZXN0ID0ge1xuICAgICAgbmFtZTogJ1VwZGF0ZWQgRGF0YWJhc2UnLFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIGJhc2VVcmw6ICdodHRwczovL25ldy1kYi5leGFtcGxlLmNvbScsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBjb25zdCBtb2NrVXBkYXRlZERhdGFTb3VyY2U6IERhdGFTb3VyY2UgPSB7XG4gICAgICBpZDogJ2RzLTEnLFxuICAgICAgbmFtZTogJ1VwZGF0ZWQgRGF0YWJhc2UnLFxuICAgICAgdHlwZTogJ3Jlc3RfYXBpJyxcbiAgICAgIHN0YXR1czogJ2Nvbm5lY3RlZCcsXG4gICAgICBvcmdhbml6YXRpb25JZDogJ29yZy0xJyxcbiAgICAgIHdvcmtzcGFjZUlkOiAnd3MtMScsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgYmFzZVVybDogJ2h0dHBzOi8vbmV3LWRiLmV4YW1wbGUuY29tJyxcbiAgICAgICAgYXV0aFR5cGU6ICdiZWFyZXInLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgZGF0YSBzb3VyY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LnB1dC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiBtb2NrVXBkYXRlZERhdGFTb3VyY2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgRGF0YVNvdXJjZVNlcnZpY2UudXBkYXRlRGF0YVNvdXJjZSgnZHMtMScsIHVwZGF0ZVJlcXVlc3QpO1xuXG4gICAgICBleHBlY3QobW9ja0FwaUNsaWVudC5wdXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvZGF0YS1zb3VyY2VzL2RzLTEnLCB1cGRhdGVSZXF1ZXN0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1VwZGF0ZWREYXRhU291cmNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXBkYXRlIG9ubHkgbmFtZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG5hbWVPbmx5VXBkYXRlID0geyBuYW1lOiAnUmVuYW1lZCBEYXRhYmFzZScgfTtcbiAgICAgIFxuICAgICAgbW9ja0FwaUNsaWVudC5wdXQubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogeyAuLi5tb2NrVXBkYXRlZERhdGFTb3VyY2UsIG5hbWU6ICdSZW5hbWVkIERhdGFiYXNlJyB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IERhdGFTb3VyY2VTZXJ2aWNlLnVwZGF0ZURhdGFTb3VyY2UoJ2RzLTEnLCBuYW1lT25seVVwZGF0ZSk7XG5cbiAgICAgIGV4cGVjdChtb2NrQXBpQ2xpZW50LnB1dCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9kYXRhLXNvdXJjZXMvZHMtMScsIG5hbWVPbmx5VXBkYXRlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubmFtZSkudG9CZSgnUmVuYW1lZCBEYXRhYmFzZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdXBkYXRlIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LnB1dC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gZmFpbGVkIHdpdGggbmV3IGNvbmZpZycsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KERhdGFTb3VyY2VTZXJ2aWNlLnVwZGF0ZURhdGFTb3VyY2UoJ2RzLTEnLCB1cGRhdGVSZXF1ZXN0KSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnQ29ubmVjdGlvbiBmYWlsZWQgd2l0aCBuZXcgY29uZmlnJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdkZWxldGVEYXRhU291cmNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZGVsZXRlIGRhdGEgc291cmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0FwaUNsaWVudC5kZWxldGUubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgc3VjY2VzczogdHJ1ZSB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KERhdGFTb3VyY2VTZXJ2aWNlLmRlbGV0ZURhdGFTb3VyY2UoJ2RzLTEnKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcblxuICAgICAgZXhwZWN0KG1vY2tBcGlDbGllbnQuZGVsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2RhdGEtc291cmNlcy9kcy0xJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkZWxldGUgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LmRlbGV0ZS5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdDYW5ub3QgZGVsZXRlIGFjdGl2ZSBkYXRhIHNvdXJjZScpKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KERhdGFTb3VyY2VTZXJ2aWNlLmRlbGV0ZURhdGFTb3VyY2UoJ2RzLTEnKSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnQ2Fubm90IGRlbGV0ZSBhY3RpdmUgZGF0YSBzb3VyY2UnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3Rlc3RDb25uZWN0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdGVzdCBzdWNjZXNzZnVsIGNvbm5lY3Rpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBEYXRhU291cmNlU2VydmljZS50ZXN0Q29ubmVjdGlvbignZHMtMScpO1xuXG4gICAgICBleHBlY3QobW9ja0FwaUNsaWVudC5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2RhdGEtc291cmNlcy9kcy0xL3Rlc3QnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGVzdCBmYWlsZWQgY29ubmVjdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBcGlDbGllbnQucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogJ0VDT05OUkVGVVNFRCcsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgRGF0YVNvdXJjZVNlcnZpY2UudGVzdENvbm5lY3Rpb24oJ2RzLTEnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIGNvbm5lY3RlZDogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnRUNPTk5SRUZVU0VEJyxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdGVzdCBBUEkgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LnBvc3QubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignQVBJIGVycm9yJykpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoRGF0YVNvdXJjZVNlcnZpY2UudGVzdENvbm5lY3Rpb24oJ2RzLTEnKSkucmVqZWN0cy50b1Rocm93KCdBUEkgZXJyb3InKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FuYWx5dGljc1NlcnZpY2UucXVlcnknLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1F1ZXJ5OiBBbmFseXRpY3NRdWVyeSA9IHtcbiAgICAgIGRhdGFTb3VyY2U6ICdkcy0xJyxcbiAgICAgIG1ldHJpY3M6IFsndXNlcnMnLCAnc2Vzc2lvbnMnXSxcbiAgICAgIGRpbWVuc2lvbnM6IFsnY291bnRyeScsICdkZXZpY2UnXSxcbiAgICAgIHRpbWVSYW5nZToge1xuICAgICAgICBzdGFydDogJzIwMjQtMDEtMDEnLFxuICAgICAgICBlbmQ6ICcyMDI0LTAxLTMxJyxcbiAgICAgICAgcHJlc2V0OiAnbGFzdDMwZGF5cycsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRhOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGltZW5zaW9uczogeyBjb3VudHJ5OiAnVVMnLCBkZXZpY2U6ICdkZXNrdG9wJyB9LFxuICAgICAgICAgICAgbWV0cmljczogeyB1c2VyczogMTAwMCwgc2Vzc2lvbnM6IDE1MDAgfSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogJzIwMjQtMDEtMDEnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGltZW5zaW9uczogeyBjb3VudHJ5OiAnREUnLCBkZXZpY2U6ICdtb2JpbGUnIH0sXG4gICAgICAgICAgICBtZXRyaWNzOiB7IHVzZXJzOiA4MDAsIHNlc3Npb25zOiAxMjAwIH0sXG4gICAgICAgICAgICB0aW1lc3RhbXA6ICcyMDI0LTAxLTAyJyxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICB0b3RhbFJvd3M6IDIsXG4gICAgICAgIHF1ZXJ5OiBtb2NrUXVlcnksXG4gICAgICAgIGV4ZWN1dGlvblRpbWU6IDQ1LFxuICAgICAgICBjYWNoZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCBleGVjdXRlIHF1ZXJ5IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBcGlDbGllbnQucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UobW9ja1Jlc3BvbnNlKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQW5hbHl0aWNzU2VydmljZS5xdWVyeShtb2NrUXVlcnkpO1xuXG4gICAgICBleHBlY3QobW9ja0FwaUNsaWVudC5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FuYWx5dGljcy9xdWVyeScsIG1vY2tRdWVyeSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tSZXNwb25zZS5kYXRhKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZXhlY3V0ZSBxdWVyeSB3aXRoIGZpbHRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBxdWVyeVdpdGhGaWx0ZXJzID0ge1xuICAgICAgICAuLi5tb2NrUXVlcnksXG4gICAgICAgIGZpbHRlcnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmaWVsZDogJ2NvdW50cnknLFxuICAgICAgICAgICAgb3BlcmF0b3I6ICdlcXVhbHMnIGFzIGNvbnN0LFxuICAgICAgICAgICAgdmFsdWU6ICdVUycsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tBcGlDbGllbnQucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UobW9ja1Jlc3BvbnNlKTtcblxuICAgICAgYXdhaXQgQW5hbHl0aWNzU2VydmljZS5xdWVyeShxdWVyeVdpdGhGaWx0ZXJzKTtcblxuICAgICAgZXhwZWN0KG1vY2tBcGlDbGllbnQucG9zdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hbmFseXRpY3MvcXVlcnknLCBxdWVyeVdpdGhGaWx0ZXJzKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHF1ZXJ5IGV4ZWN1dGlvbiBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBcGlDbGllbnQucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogJ1N5bnRheCBlcnJvciBpbiBTUUwgcXVlcnknLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChBbmFseXRpY3NTZXJ2aWNlLnF1ZXJ5KG1vY2tRdWVyeSkpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coJ1N5bnRheCBlcnJvciBpbiBTUUwgcXVlcnknKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHF1ZXJ5IHJlc3VsdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgIHRvdGFsUm93czogMCxcbiAgICAgICAgICBxdWVyeTogbW9ja1F1ZXJ5LFxuICAgICAgICAgIGV4ZWN1dGlvblRpbWU6IDEwLFxuICAgICAgICAgIGNhY2hlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQW5hbHl0aWNzU2VydmljZS5xdWVyeShtb2NrUXVlcnkpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudG90YWxSb3dzKS50b0JlKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0QXZhaWxhYmxlTWV0cmljcyBhbmQgZ2V0QXZhaWxhYmxlRGltZW5zaW9ucycsICgpID0+IHtcbiAgICBjb25zdCBtb2NrTWV0cmljcyA9IFsncmV2ZW51ZScsICd1c2VycycsICdzZXNzaW9ucycsICdwYWdldmlld3MnXTtcbiAgICBjb25zdCBtb2NrRGltZW5zaW9ucyA9IFsnY291bnRyeScsICdkZXZpY2UnLCAnYnJvd3NlcicsICdwYWdlJ107XG5cbiAgICBpdCgnc2hvdWxkIGdldCBhdmFpbGFibGUgbWV0cmljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogbW9ja01ldHJpY3MsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB9O1xuICAgICAgbW9ja0FwaUNsaWVudC5nZXQubW9ja1Jlc29sdmVkVmFsdWVPbmNlKG1vY2tSZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IERhdGFTb3VyY2VTZXJ2aWNlLmdldEF2YWlsYWJsZU1ldHJpY3MoJ2RzLTEnKTtcblxuICAgICAgZXhwZWN0KG1vY2tBcGlDbGllbnQuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2RhdGEtc291cmNlcy9kcy0xL21ldHJpY3MnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja01ldHJpY3MpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBnZXQgYXZhaWxhYmxlIGRpbWVuc2lvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IG1vY2tEaW1lbnNpb25zLFxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIG1vY2tBcGlDbGllbnQuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZShtb2NrUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBEYXRhU291cmNlU2VydmljZS5nZXRBdmFpbGFibGVEaW1lbnNpb25zKCdkcy0xJyk7XG5cbiAgICAgIGV4cGVjdChtb2NrQXBpQ2xpZW50LmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9kYXRhLXNvdXJjZXMvZHMtMS9kaW1lbnNpb25zJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tEaW1lbnNpb25zKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJhcGlDbGllbnQiLCJnZXQiLCJmbiIsInBvc3QiLCJwdXQiLCJkZWxldGUiLCJjcmVhdGVRdWVyeUZ1bmN0aW9uIiwicmVzcG9uc2UiLCJzdWNjZXNzIiwiRXJyb3IiLCJtZXNzYWdlIiwiZGF0YSIsImRlc2NyaWJlIiwibW9ja0FwaUNsaWVudCIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja0RhdGFTb3VyY2VzIiwiaWQiLCJuYW1lIiwidHlwZSIsInN0YXR1cyIsIm9yZ2FuaXphdGlvbklkIiwid29ya3NwYWNlSWQiLCJsYXN0U3luYyIsImNvbmZpZyIsImFjY291bnRJZCIsInByb3BlcnR5SWQiLCJ2aWV3SWQiLCJiYXNlVXJsIiwiYXV0aFR5cGUiLCJpdCIsIm1vY2tSZXNwb25zZSIsIm1vY2tSZXNvbHZlZFZhbHVlT25jZSIsInJlc3VsdCIsIkRhdGFTb3VyY2VTZXJ2aWNlIiwiZ2V0RGF0YVNvdXJjZXMiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInRvRXF1YWwiLCJ0b0hhdmVMZW5ndGgiLCJ0b0JlIiwibW9ja1JlamVjdGVkVmFsdWVPbmNlIiwicmVqZWN0cyIsInRvVGhyb3ciLCJtb2NrRGF0YVNvdXJjZSIsImdldERhdGFTb3VyY2UiLCJjcmVhdGVSZXF1ZXN0IiwibW9ja0NyZWF0ZWREYXRhU291cmNlIiwiY3JlYXRlRGF0YVNvdXJjZSIsInJlcXVlc3RXaXRob3V0V29ya3NwYWNlIiwidG9CZVVuZGVmaW5lZCIsInVwZGF0ZVJlcXVlc3QiLCJtb2NrVXBkYXRlZERhdGFTb3VyY2UiLCJ1cGRhdGVEYXRhU291cmNlIiwibmFtZU9ubHlVcGRhdGUiLCJkZWxldGVEYXRhU291cmNlIiwicmVzb2x2ZXMiLCJub3QiLCJjb25uZWN0ZWQiLCJ0ZXN0Q29ubmVjdGlvbiIsImVycm9yIiwibW9ja1F1ZXJ5IiwiZGF0YVNvdXJjZSIsIm1ldHJpY3MiLCJkaW1lbnNpb25zIiwidGltZVJhbmdlIiwic3RhcnQiLCJlbmQiLCJwcmVzZXQiLCJjb3VudHJ5IiwiZGV2aWNlIiwidXNlcnMiLCJzZXNzaW9ucyIsInRpbWVzdGFtcCIsInRvdGFsUm93cyIsInF1ZXJ5IiwiZXhlY3V0aW9uVGltZSIsImNhY2hlZCIsIkFuYWx5dGljc1NlcnZpY2UiLCJxdWVyeVdpdGhGaWx0ZXJzIiwiZmlsdGVycyIsImZpZWxkIiwib3BlcmF0b3IiLCJ2YWx1ZSIsIm1vY2tNZXRyaWNzIiwibW9ja0RpbWVuc2lvbnMiLCJnZXRBdmFpbGFibGVNZXRyaWNzIiwiZ2V0QXZhaWxhYmxlRGltZW5zaW9ucyJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDO0FBT0Qsc0JBQXNCO0FBQ3RCQSxLQUFLQyxJQUFJLENBQUMsWUFBWSxJQUFPLENBQUE7UUFDM0JDLFdBQVc7WUFDVEMsS0FBS0gsS0FBS0ksRUFBRTtZQUNaQyxNQUFNTCxLQUFLSSxFQUFFO1lBQ2JFLEtBQUtOLEtBQUtJLEVBQUU7WUFDWkcsUUFBUVAsS0FBS0ksRUFBRTtRQUNqQjtRQUNBSSxxQkFBcUIsQ0FBQ0osS0FBaUI7Z0JBQ3JDLE1BQU1LLFdBQVcsTUFBTUw7Z0JBQ3ZCLElBQUksQ0FBQ0ssU0FBU0MsT0FBTyxFQUFFO29CQUNyQixNQUFNLElBQUlDLE1BQU1GLFNBQVNHLE9BQU8sSUFBSTtnQkFDdEM7Z0JBQ0EsT0FBT0gsU0FBU0ksSUFBSTtZQUN0QjtJQUNGLENBQUE7Ozs7NkJBbEJv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