{"version":3,"sources":["/Users/zweigen/Sites/daten-see-v2/src/contexts/AuthContext.tsx"],"sourcesContent":["'use client';\n\nimport { createContext, useContext, useEffect, useState, useCallback, ReactNode } from 'react';\n\nimport { tokenManager, type TokenManager } from '@/lib/auth/token';\nimport { appLogger } from '@/lib/monitoring/logger.config';\n\n// User interface\nexport interface User {\n  id: string;\n  email: string;\n  name: string;\n  role: 'user' | 'admin';\n  avatar?: string;\n}\n\n// Auth state interface\nexport interface AuthState {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n}\n\n// Auth context interface\nexport interface AuthContextType extends AuthState {\n  // Auth actions\n  login: (email: string, password: string) => Promise<void>;\n  logout: () => void;\n  refreshToken: () => Promise<boolean>;\n  clearError: () => void;\n  \n  // User actions\n  updateUser: (updates: Partial<Pick<User, 'name' | 'avatar'>>) => void;\n  \n  // Token utilities\n  getAccessToken: () => string | null;\n  needsRefresh: () => boolean;\n}\n\n// Create context\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// Props interface with optional dependency injection\ninterface AuthProviderProps {\n  children: ReactNode;\n  tokenManager?: TokenManager; // Optional for testing and flexibility\n}\n\n/**\n * Authentication Context Provider\n * Manages user authentication state without Zustand\n * Uses React Context + TanStack Query for server state\n */\nexport function AuthProvider({ children, tokenManager: injectedTokenManager }: AuthProviderProps): React.ReactElement {\n  // Dependency Injection: Use injected tokenManager or default to singleton\n  const activeTokenManager = injectedTokenManager ?? tokenManager;\n  \n  // Production safety check\n  if (process.env.NODE_ENV === 'production' && injectedTokenManager && injectedTokenManager !== tokenManager) {\n    appLogger.warn('Custom tokenManager injected in production environment', {\n      isCustomTokenManager: true,\n      hasInjectedTokenManager: !!injectedTokenManager,\n    });\n  }\n  \n  // Comprehensive TokenManager Interface Validation\n  if (injectedTokenManager) {\n    // Type validation\n    if (typeof injectedTokenManager !== 'object' || injectedTokenManager === null) {\n      throw new Error('Invalid tokenManager: must be a non-null object');\n    }\n\n    // Required methods validation\n    const requiredMethods = [\n      'getTokenInfo',\n      'setTokens', \n      'clearTokens',\n      'updateApiClientToken',\n      'getCurrentUserInfo',\n      'needsRefresh',\n      'getAccessToken',\n      'getRefreshToken',\n      'parseTokenPayload'\n    ];\n\n    const missingMethods = requiredMethods.filter(method => \n      !injectedTokenManager[method as keyof TokenManager] || typeof injectedTokenManager[method as keyof TokenManager] !== 'function'\n    );\n\n    if (missingMethods.length > 0) {\n      throw new Error(`Invalid tokenManager: missing required methods: ${missingMethods.join(', ')}. TokenManager must implement the full interface.`);\n    }\n\n    // Production environment extra validation\n    if (process.env.NODE_ENV === 'production') {\n      // Check if this looks like a test mock (suspicious patterns)\n      const mockIndicators = [\n        injectedTokenManager.constructor?.name === 'Object', // Plain object (likely mock)\n        'mockReturnValue' in injectedTokenManager.getTokenInfo, // Jest mock function\n        injectedTokenManager.getTokenInfo.toString().includes('jest'), // Jest signature\n      ];\n\n      if (mockIndicators.some(Boolean)) {\n        appLogger.error('Suspicious tokenManager detected in production', {\n          constructorName: injectedTokenManager.constructor?.name,\n          hasMockSignature: mockIndicators[1],\n          hasJestSignature: mockIndicators[2],\n          isProduction: true,\n        });\n        \n        // In production, reject obvious test mocks\n        throw new Error('Invalid tokenManager: test mocks are not allowed in production environment');\n      }\n    }\n\n    appLogger.debug('TokenManager validation passed', {\n      isInjected: true,\n      methodCount: requiredMethods.length,\n      environment: process.env.NODE_ENV,\n    });\n  }\n  const [authState, setAuthState] = useState<AuthState>({\n    user: null,\n    isAuthenticated: false,\n    isLoading: true, // Start with loading to check existing tokens\n    error: null,\n  });\n\n  // Initialize auth state from stored tokens\n  useEffect(() => {\n    const initializeAuth = async (): Promise<void> => {\n      try {\n        appLogger.debug('Initializing authentication state');\n\n        const tokenInfo = activeTokenManager.getTokenInfo();\n        \n        if (tokenInfo.isValid && tokenInfo.token) {\n          // Get user info from token\n          const userInfo = activeTokenManager.getCurrentUserInfo();\n          \n          if (userInfo?.userId && userInfo?.email) {\n            const user: User = {\n              id: userInfo.userId!,\n              email: userInfo.email,\n              name: userInfo.email.split('@')[0] || 'Unknown User', // Fallback name\n              role: (userInfo.role as 'user' | 'admin') || 'user',\n            };\n\n            // Update API client with token\n            activeTokenManager.updateApiClientToken();\n\n            setAuthState({\n              user,\n              isAuthenticated: true,\n              isLoading: false,\n              error: null,\n            });\n\n            appLogger.info('Authentication restored from stored token', {\n              userId: user.id,\n              email: user.email,\n              role: user.role,\n            });\n          } else {\n            throw new Error('Invalid token payload');\n          }\n        } else {\n          // No valid token found\n          setAuthState({\n            user: null,\n            isAuthenticated: false,\n            isLoading: false,\n            error: null,\n          });\n\n          appLogger.debug('No valid authentication token found');\n        }\n      } catch (error) {\n        appLogger.error('Failed to initialize authentication', {\n          error: error instanceof Error ? error.message : 'Unknown error',\n        });\n\n        // Clear invalid tokens\n        activeTokenManager.clearTokens();\n        \n        setAuthState({\n          user: null,\n          isAuthenticated: false,\n          isLoading: false,\n          error: 'Authentication initialization failed',\n        });\n      }\n    };\n\n    initializeAuth();\n  }, [activeTokenManager]);\n\n  // Refresh token function\n  const refreshToken = useCallback(async (): Promise<boolean> => {\n    try {\n      const refreshTokenValue = activeTokenManager.getRefreshToken();\n      \n      if (!refreshTokenValue) {\n        throw new Error('No refresh token available');\n      }\n\n      appLogger.debug('Token refresh attempt started');\n\n      // TODO: Replace with actual API call\n      await new Promise(resolve => setTimeout(resolve, 500));\n\n      // Mock successful refresh\n      const mockTokenData = {\n        token: 'refreshed.jwt.token',\n        refreshToken: refreshTokenValue, // Keep same refresh token\n        expiresAt: new Date(Date.now() + 60 * 60 * 1000).toISOString(),\n      };\n\n      activeTokenManager.setTokens(mockTokenData);\n      activeTokenManager.updateApiClientToken();\n\n      appLogger.info('Token refresh successful');\n      return true;\n\n    } catch (error) {\n      appLogger.error('Token refresh failed', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n\n      // Clear tokens and update state on refresh failure\n      activeTokenManager.clearTokens();\n      setAuthState({\n        user: null,\n        isAuthenticated: false,\n        isLoading: false,\n        error: null,\n      });\n      return false;\n    }\n  }, [activeTokenManager]);\n\n  // Auto-refresh token when needed\n  useEffect(() => {\n    if (!authState.isAuthenticated) return;\n\n    const checkTokenRefresh = async (): Promise<void> => {\n      if (activeTokenManager.needsRefresh()) {\n        appLogger.debug('Token needs refresh, attempting refresh');\n        refreshToken().catch((error) => {\n          appLogger.error('Auto token refresh failed', { error });\n        });\n      }\n    };\n\n    // Check every 5 minutes\n    const interval = setInterval(checkTokenRefresh, 5 * 60 * 1000);\n    \n    // Check immediately\n    checkTokenRefresh();\n\n    return (): void => clearInterval(interval);\n  }, [authState.isAuthenticated, refreshToken, activeTokenManager]);\n\n  // Login function (will be enhanced with TanStack mutation)\n  const login = async (email: string): Promise<void> => {\n    setAuthState(prev => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      appLogger.info('Login attempt started', { email });\n\n      // TODO: Replace with actual API call via TanStack mutation\n      // For now, mock successful login\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      // Mock successful response\n      const mockTokenData = {\n        token: 'mock.jwt.token',\n        refreshToken: 'mock.refresh.token',\n        expiresAt: new Date(Date.now() + 60 * 60 * 1000).toISOString(), // 1 hour\n      };\n\n      const mockUser: User = {\n        id: 'user-1',\n        email,\n        name: email.split('@')[0] || 'Unknown User',\n        role: 'user',\n      };\n\n      // Store tokens\n      activeTokenManager.setTokens(mockTokenData);\n      activeTokenManager.updateApiClientToken();\n\n      setAuthState({\n        user: mockUser,\n        isAuthenticated: true,\n        isLoading: false,\n        error: null,\n      });\n\n      appLogger.info('Login successful', {\n        userId: mockUser.id,\n        email: mockUser.email,\n      });\n\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Login failed';\n      \n      appLogger.error('Login failed', {\n        email,\n        error: errorMessage,\n      });\n\n      setAuthState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage,\n      }));\n\n      throw error;\n    }\n  };\n\n  // Logout function\n  const logout = (): void => {\n    appLogger.info('Logout started', {\n      ...(authState.user?.id && { userId: authState.user.id }),\n    });\n\n    // Clear tokens using active token manager\n    activeTokenManager.clearTokens();\n\n    // Reset auth state\n    setAuthState({\n      user: null,\n      isAuthenticated: false,\n      isLoading: false,\n      error: null,\n    });\n\n    appLogger.info('Logout completed');\n  };\n\n\n  // Clear error\n  const clearError = (): void => {\n    setAuthState(prev => ({ ...prev, error: null }));\n  };\n\n  // Update user profile\n  const updateUser = (updates: Partial<Pick<User, 'name' | 'avatar'>>): void => {\n    if (!authState.user) return;\n\n    const updatedUser = { ...authState.user, ...updates };\n\n    setAuthState(prev => ({\n      ...prev,\n      user: updatedUser,\n    }));\n\n    appLogger.info('User profile updated', {\n      userId: updatedUser.id,\n      updates,\n    });\n  };\n\n  // Token utilities\n  const getAccessToken = (): string | null => {\n    return activeTokenManager.getAccessToken();\n  };\n\n  const needsRefresh = (): boolean => {\n    return activeTokenManager.needsRefresh();\n  };\n\n  // Context value\n  const contextValue: AuthContextType = {\n    // State\n    ...authState,\n    \n    // Actions\n    login,\n    logout,\n    refreshToken,\n    clearError,\n    updateUser,\n    \n    // Utilities\n    getAccessToken,\n    needsRefresh,\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\n/**\n * Hook to use authentication context\n */\nexport function useAuth(): AuthContextType {\n  const context = useContext(AuthContext);\n  \n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  \n  return context;\n}\n\n// Export types\nexport { AuthContext };"],"names":["AuthContext","AuthProvider","useAuth","createContext","undefined","children","tokenManager","injectedTokenManager","activeTokenManager","process","env","NODE_ENV","appLogger","warn","isCustomTokenManager","hasInjectedTokenManager","Error","requiredMethods","missingMethods","filter","method","length","join","mockIndicators","name","getTokenInfo","toString","includes","some","Boolean","error","constructorName","hasMockSignature","hasJestSignature","isProduction","debug","isInjected","methodCount","environment","authState","setAuthState","useState","user","isAuthenticated","isLoading","useEffect","initializeAuth","tokenInfo","isValid","token","userInfo","getCurrentUserInfo","userId","email","id","split","role","updateApiClientToken","info","message","clearTokens","refreshToken","useCallback","refreshTokenValue","getRefreshToken","Promise","resolve","setTimeout","mockTokenData","expiresAt","Date","now","toISOString","setTokens","checkTokenRefresh","needsRefresh","catch","interval","setInterval","clearInterval","login","prev","mockUser","errorMessage","logout","clearError","updateUser","updates","updatedUser","getAccessToken","contextValue","Provider","value","context","useContext"],"mappings":"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"}