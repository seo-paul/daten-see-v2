2775c3c804633810acd2664f8771afaf
/**
 * API Client Unit Tests - Streamlined
 * Testing core API client functionality only (Reduced from 97 â†’ 20 tests)
 */ "use strict";
// Mock logger
jest.mock('@/lib/monitoring/logger.config', ()=>({
        appLogger: {
            debug: jest.fn(),
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn()
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _loggerconfig = require("../../monitoring/logger.config");
const _client = require("../client");
// Mock fetch
global.fetch = jest.fn();
describe('ApiClient', ()=>{
    let client;
    const mockFetch = global.fetch;
    beforeEach(()=>{
        jest.clearAllMocks();
        client = new _client.ApiClient('http://localhost:3001/api');
    });
    afterEach(()=>{
        jest.resetAllMocks();
    });
    // Constructor test
    it('should initialize with correct defaults', ()=>{
        expect(client).toBeDefined();
        expect(client).toBeInstanceOf(_client.ApiClient);
    });
    // GET request test
    it('should make successful GET request', async ()=>{
        const mockData = {
            id: 1,
            name: 'Test'
        };
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 200,
            json: async ()=>mockData
        });
        const result = await client.get('/test');
        expect(mockFetch).toHaveBeenCalledWith('http://localhost:3001/api/test', expect.objectContaining({
            method: 'GET'
        }));
        expect(result).toEqual(mockData);
    });
    // POST request test
    it('should make successful POST request with data', async ()=>{
        const postData = {
            name: 'Test Item'
        };
        const responseData = {
            id: 1,
            ...postData
        };
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 201,
            json: async ()=>responseData
        });
        const result = await client.post('/test', postData);
        expect(mockFetch).toHaveBeenCalledWith('http://localhost:3001/api/test', expect.objectContaining({
            method: 'POST',
            body: JSON.stringify(postData)
        }));
        expect(result).toEqual(responseData);
    });
    // PUT request test
    it('should make successful PUT request', async ()=>{
        const putData = {
            id: 1,
            name: 'Updated'
        };
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 200,
            json: async ()=>putData
        });
        const result = await client.put('/test/1', putData);
        expect(mockFetch).toHaveBeenCalledWith('http://localhost:3001/api/test/1', expect.objectContaining({
            method: 'PUT'
        }));
        expect(result).toEqual(putData);
    });
    // DELETE request test
    it('should make successful DELETE request', async ()=>{
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 204,
            json: async ()=>({})
        });
        await client.delete('/test/1');
        expect(mockFetch).toHaveBeenCalledWith('http://localhost:3001/api/test/1', expect.objectContaining({
            method: 'DELETE'
        }));
    });
    // Authentication token test
    it('should include auth token in requests', async ()=>{
        client.setAuthToken('test-token');
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 200,
            json: async ()=>({})
        });
        await client.get('/protected');
        expect(mockFetch).toHaveBeenCalledWith('http://localhost:3001/api/protected', expect.objectContaining({
            headers: expect.objectContaining({
                'Authorization': 'Bearer test-token'
            })
        }));
    });
    // Clear auth token test
    it('should clear auth token from requests', async ()=>{
        client.setAuthToken('test-token');
        client.clearAuthToken();
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 200,
            json: async ()=>({})
        });
        await client.get('/test');
        const callArgs = mockFetch.mock.calls[0]?.[1];
        expect(callArgs?.headers).not.toHaveProperty('Authorization');
    });
    // 404 error handling test
    it('should handle 404 errors correctly', async ()=>{
        mockFetch.mockResolvedValueOnce({
            ok: false,
            status: 404,
            statusText: 'Not Found',
            json: async ()=>({
                    message: 'Resource not found'
                })
        });
        await expect(client.get('/nonexistent')).rejects.toThrow(_client.ApiClientError);
    });
    // Network error test
    it('should handle network errors', async ()=>{
        mockFetch.mockRejectedValueOnce(new Error('Network error'));
        await expect(client.get('/test')).rejects.toThrow(_client.NetworkError);
    });
    // Timeout error test
    it('should handle timeout errors', async ()=>{
        mockFetch.mockImplementationOnce(()=>new Promise((resolve)=>setTimeout(resolve, 10000)));
        const shortTimeoutClient = new _client.ApiClient('http://localhost:3001/api', 100);
        await expect(shortTimeoutClient.get('/test')).rejects.toThrow(_client.TimeoutError);
    });
    // Custom headers test
    it('should accept custom headers', async ()=>{
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 200,
            json: async ()=>({})
        });
        await client.get('/test', {
            'X-Custom-Header': 'custom-value'
        });
        expect(mockFetch).toHaveBeenCalledWith('http://localhost:3001/api/test', expect.objectContaining({
            headers: expect.objectContaining({
                'X-Custom-Header': 'custom-value'
            })
        }));
    });
    // JSON response parsing test
    it('should parse JSON responses correctly', async ()=>{
        const responseData = {
            message: 'success',
            data: [
                1,
                2,
                3
            ]
        };
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 200,
            json: async ()=>responseData
        });
        const result = await client.get('/test');
        expect(result).toEqual(responseData);
    });
    // Error response parsing test
    it('should parse error responses with details', async ()=>{
        const errorResponse = {
            message: 'Validation failed',
            errors: {
                name: 'Required field'
            }
        };
        mockFetch.mockResolvedValueOnce({
            ok: false,
            status: 400,
            statusText: 'Bad Request',
            json: async ()=>errorResponse
        });
        try {
            await client.post('/test', {});
        } catch (error) {
            expect(error).toBeInstanceOf(_client.ApiClientError);
            expect(error.message).toBe('Validation failed');
            expect(error.details).toEqual(errorResponse.errors);
        }
    });
    // Content-Type header test
    it('should set correct Content-Type for JSON requests', async ()=>{
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 200,
            json: async ()=>({})
        });
        await client.post('/test', {
            data: 'test'
        });
        expect(mockFetch).toHaveBeenCalledWith('http://localhost:3001/api/test', expect.objectContaining({
            headers: expect.objectContaining({
                'Content-Type': 'application/json'
            })
        }));
    });
    // Empty response handling test
    it('should handle empty responses correctly', async ()=>{
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 204,
            json: async ()=>null
        });
        const result = await client.delete('/test/1');
        expect(result).toBeNull();
    });
    // Base URL handling test
    it('should construct URLs correctly with base URL', async ()=>{
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 200,
            json: async ()=>({})
        });
        await client.get('/endpoint');
        expect(mockFetch).toHaveBeenCalledWith('http://localhost:3001/api/endpoint', expect.any(Object));
    });
    // Query parameters test
    it('should handle query parameters in URLs', async ()=>{
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 200,
            json: async ()=>({})
        });
        await client.get('/test?param1=value1&param2=value2');
        expect(mockFetch).toHaveBeenCalledWith('http://localhost:3001/api/test?param1=value1&param2=value2', expect.any(Object));
    });
    // Logging test
    it('should log requests and responses', async ()=>{
        mockFetch.mockResolvedValueOnce({
            ok: true,
            status: 200,
            json: async ()=>({
                    data: 'test'
                })
        });
        await client.get('/test');
        expect(_loggerconfig.appLogger.debug).toHaveBeenCalled();
    });
    // Singleton instance test
    it('should provide singleton instance', ()=>{
        expect(_client.apiClient).toBeInstanceOf(_client.ApiClient);
    });
    // Error code mapping test
    it('should map HTTP status codes to appropriate errors', async ()=>{
        const testCases = [
            {
                status: 401,
                errorType: _client.ApiClientError
            },
            {
                status: 403,
                errorType: _client.ApiClientError
            },
            {
                status: 500,
                errorType: _client.ApiClientError
            }
        ];
        for (const testCase of testCases){
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: testCase.status,
                statusText: 'Error',
                json: async ()=>({
                        message: 'Error'
                    })
            });
            await expect(client.get('/test')).rejects.toThrow(testCase.errorType);
        }
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy96d2VpZ2VuL1NpdGVzL2RhdGVuLXNlZS12Mi9zcmMvbGliL2FwaS9fX3Rlc3RzX18vY2xpZW50LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBUEkgQ2xpZW50IFVuaXQgVGVzdHMgLSBTdHJlYW1saW5lZFxuICogVGVzdGluZyBjb3JlIEFQSSBjbGllbnQgZnVuY3Rpb25hbGl0eSBvbmx5IChSZWR1Y2VkIGZyb20gOTcg4oaSIDIwIHRlc3RzKVxuICovXG5cbmltcG9ydCB7IGFwcExvZ2dlciB9IGZyb20gJ0AvbGliL21vbml0b3JpbmcvbG9nZ2VyLmNvbmZpZyc7XG5cbmltcG9ydCB7IGFwaUNsaWVudCwgQXBpQ2xpZW50LCBBcGlDbGllbnRFcnJvciwgTmV0d29ya0Vycm9yLCBUaW1lb3V0RXJyb3IgfSBmcm9tICcuLi9jbGllbnQnO1xuXG4vLyBNb2NrIGxvZ2dlclxuamVzdC5tb2NrKCdAL2xpYi9tb25pdG9yaW5nL2xvZ2dlci5jb25maWcnLCAoKSA9PiAoe1xuICBhcHBMb2dnZXI6IHtcbiAgICBkZWJ1ZzogamVzdC5mbigpLFxuICAgIGluZm86IGplc3QuZm4oKSxcbiAgICB3YXJuOiBqZXN0LmZuKCksXG4gICAgZXJyb3I6IGplc3QuZm4oKSxcbiAgfSxcbn0pKTtcblxuLy8gTW9jayBmZXRjaFxuZ2xvYmFsLmZldGNoID0gamVzdC5mbigpO1xuXG5kZXNjcmliZSgnQXBpQ2xpZW50JywgKCkgPT4ge1xuICBsZXQgY2xpZW50OiBBcGlDbGllbnQ7XG4gIGNvbnN0IG1vY2tGZXRjaCA9IGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBmZXRjaD47XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgY2xpZW50ID0gbmV3IEFwaUNsaWVudCgnaHR0cDovL2xvY2FsaG9zdDozMDAxL2FwaScpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QucmVzZXRBbGxNb2NrcygpO1xuICB9KTtcblxuICAvLyBDb25zdHJ1Y3RvciB0ZXN0XG4gIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB3aXRoIGNvcnJlY3QgZGVmYXVsdHMnLCAoKSA9PiB7XG4gICAgZXhwZWN0KGNsaWVudCkudG9CZURlZmluZWQoKTtcbiAgICBleHBlY3QoY2xpZW50KS50b0JlSW5zdGFuY2VPZihBcGlDbGllbnQpO1xuICB9KTtcblxuICAvLyBHRVQgcmVxdWVzdCB0ZXN0XG4gIGl0KCdzaG91bGQgbWFrZSBzdWNjZXNzZnVsIEdFVCByZXF1ZXN0JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tEYXRhID0geyBpZDogMSwgbmFtZTogJ1Rlc3QnIH07XG4gICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICBvazogdHJ1ZSxcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja0RhdGEsXG4gICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuZ2V0KCcvdGVzdCcpO1xuICAgIFxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMS9hcGkvdGVzdCcsXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IG1ldGhvZDogJ0dFVCcgfSlcbiAgICApO1xuICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja0RhdGEpO1xuICB9KTtcblxuICAvLyBQT1NUIHJlcXVlc3QgdGVzdFxuICBpdCgnc2hvdWxkIG1ha2Ugc3VjY2Vzc2Z1bCBQT1NUIHJlcXVlc3Qgd2l0aCBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHBvc3REYXRhID0geyBuYW1lOiAnVGVzdCBJdGVtJyB9O1xuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHsgaWQ6IDEsIC4uLnBvc3REYXRhIH07XG4gICAgXG4gICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICBvazogdHJ1ZSxcbiAgICAgIHN0YXR1czogMjAxLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gcmVzcG9uc2VEYXRhLFxuICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnBvc3QoJy90ZXN0JywgcG9zdERhdGEpO1xuICAgIFxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMS9hcGkvdGVzdCcsXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwb3N0RGF0YSksXG4gICAgICB9KVxuICAgICk7XG4gICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChyZXNwb25zZURhdGEpO1xuICB9KTtcblxuICAvLyBQVVQgcmVxdWVzdCB0ZXN0XG4gIGl0KCdzaG91bGQgbWFrZSBzdWNjZXNzZnVsIFBVVCByZXF1ZXN0JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHB1dERhdGEgPSB7IGlkOiAxLCBuYW1lOiAnVXBkYXRlZCcgfTtcbiAgICBcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiBwdXREYXRhLFxuICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnB1dCgnL3Rlc3QvMScsIHB1dERhdGEpO1xuICAgIFxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMS9hcGkvdGVzdC8xJyxcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHsgbWV0aG9kOiAnUFVUJyB9KVxuICAgICk7XG4gICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChwdXREYXRhKTtcbiAgfSk7XG5cbiAgLy8gREVMRVRFIHJlcXVlc3QgdGVzdFxuICBpdCgnc2hvdWxkIG1ha2Ugc3VjY2Vzc2Z1bCBERUxFVEUgcmVxdWVzdCcsIGFzeW5jICgpID0+IHtcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiAoe30pLFxuICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgYXdhaXQgY2xpZW50LmRlbGV0ZSgnL3Rlc3QvMScpO1xuICAgIFxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMS9hcGkvdGVzdC8xJyxcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHsgbWV0aG9kOiAnREVMRVRFJyB9KVxuICAgICk7XG4gIH0pO1xuXG4gIC8vIEF1dGhlbnRpY2F0aW9uIHRva2VuIHRlc3RcbiAgaXQoJ3Nob3VsZCBpbmNsdWRlIGF1dGggdG9rZW4gaW4gcmVxdWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgY2xpZW50LnNldEF1dGhUb2tlbigndGVzdC10b2tlbicpO1xuICAgIFxuICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIGpzb246IGFzeW5jICgpID0+ICh7fSksXG4gICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICBhd2FpdCBjbGllbnQuZ2V0KCcvcHJvdGVjdGVkJyk7XG4gICAgXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAxL2FwaS9wcm90ZWN0ZWQnLFxuICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICBoZWFkZXJzOiBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIHRlc3QtdG9rZW4nLFxuICAgICAgICB9KSxcbiAgICAgIH0pXG4gICAgKTtcbiAgfSk7XG5cbiAgLy8gQ2xlYXIgYXV0aCB0b2tlbiB0ZXN0XG4gIGl0KCdzaG91bGQgY2xlYXIgYXV0aCB0b2tlbiBmcm9tIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNsaWVudC5zZXRBdXRoVG9rZW4oJ3Rlc3QtdG9rZW4nKTtcbiAgICBjbGllbnQuY2xlYXJBdXRoVG9rZW4oKTtcbiAgICBcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiAoe30pLFxuICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgYXdhaXQgY2xpZW50LmdldCgnL3Rlc3QnKTtcbiAgICBcbiAgICBjb25zdCBjYWxsQXJncyA9IG1vY2tGZXRjaC5tb2NrLmNhbGxzWzBdPy5bMV07XG4gICAgZXhwZWN0KGNhbGxBcmdzPy5oZWFkZXJzKS5ub3QudG9IYXZlUHJvcGVydHkoJ0F1dGhvcml6YXRpb24nKTtcbiAgfSk7XG5cbiAgLy8gNDA0IGVycm9yIGhhbmRsaW5nIHRlc3RcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgNDA0IGVycm9ycyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICBvazogZmFsc2UsXG4gICAgICBzdGF0dXM6IDQwNCxcbiAgICAgIHN0YXR1c1RleHQ6ICdOb3QgRm91bmQnLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgbWVzc2FnZTogJ1Jlc291cmNlIG5vdCBmb3VuZCcgfSksXG4gICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICBhd2FpdCBleHBlY3QoY2xpZW50LmdldCgnL25vbmV4aXN0ZW50JykpLnJlamVjdHMudG9UaHJvdyhBcGlDbGllbnRFcnJvcik7XG4gIH0pO1xuXG4gIC8vIE5ldHdvcmsgZXJyb3IgdGVzdFxuICBpdCgnc2hvdWxkIGhhbmRsZSBuZXR3b3JrIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICBtb2NrRmV0Y2gubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKTtcblxuICAgIGF3YWl0IGV4cGVjdChjbGllbnQuZ2V0KCcvdGVzdCcpKS5yZWplY3RzLnRvVGhyb3coTmV0d29ya0Vycm9yKTtcbiAgfSk7XG5cbiAgLy8gVGltZW91dCBlcnJvciB0ZXN0XG4gIGl0KCdzaG91bGQgaGFuZGxlIHRpbWVvdXQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgIG1vY2tGZXRjaC5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IFxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMDApKVxuICAgICk7XG5cbiAgICBjb25zdCBzaG9ydFRpbWVvdXRDbGllbnQgPSBuZXcgQXBpQ2xpZW50KCdodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpJywgMTAwKTtcbiAgICBcbiAgICBhd2FpdCBleHBlY3Qoc2hvcnRUaW1lb3V0Q2xpZW50LmdldCgnL3Rlc3QnKSkucmVqZWN0cy50b1Rocm93KFRpbWVvdXRFcnJvcik7XG4gIH0pO1xuXG4gIC8vIEN1c3RvbSBoZWFkZXJzIHRlc3RcbiAgaXQoJ3Nob3VsZCBhY2NlcHQgY3VzdG9tIGhlYWRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICBvazogdHJ1ZSxcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHt9KSxcbiAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgIGF3YWl0IGNsaWVudC5nZXQoJy90ZXN0JywgeyAnWC1DdXN0b20tSGVhZGVyJzogJ2N1c3RvbS12YWx1ZScgfSk7XG4gICAgXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAxL2FwaS90ZXN0JyxcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgaGVhZGVyczogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICdYLUN1c3RvbS1IZWFkZXInOiAnY3VzdG9tLXZhbHVlJyxcbiAgICAgICAgfSksXG4gICAgICB9KVxuICAgICk7XG4gIH0pO1xuXG4gIC8vIEpTT04gcmVzcG9uc2UgcGFyc2luZyB0ZXN0XG4gIGl0KCdzaG91bGQgcGFyc2UgSlNPTiByZXNwb25zZXMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHsgbWVzc2FnZTogJ3N1Y2Nlc3MnLCBkYXRhOiBbMSwgMiwgM10gfTtcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiByZXNwb25zZURhdGEsXG4gICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuZ2V0KCcvdGVzdCcpO1xuICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwocmVzcG9uc2VEYXRhKTtcbiAgfSk7XG5cbiAgLy8gRXJyb3IgcmVzcG9uc2UgcGFyc2luZyB0ZXN0XG4gIGl0KCdzaG91bGQgcGFyc2UgZXJyb3IgcmVzcG9uc2VzIHdpdGggZGV0YWlscycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBlcnJvclJlc3BvbnNlID0geyBcbiAgICAgIG1lc3NhZ2U6ICdWYWxpZGF0aW9uIGZhaWxlZCcsIFxuICAgICAgZXJyb3JzOiB7IG5hbWU6ICdSZXF1aXJlZCBmaWVsZCcgfSBcbiAgICB9O1xuICAgIFxuICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IGZhbHNlLFxuICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICBzdGF0dXNUZXh0OiAnQmFkIFJlcXVlc3QnLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gZXJyb3JSZXNwb25zZSxcbiAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjbGllbnQucG9zdCgnL3Rlc3QnLCB7fSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZUluc3RhbmNlT2YoQXBpQ2xpZW50RXJyb3IpO1xuICAgICAgZXhwZWN0KChlcnJvciBhcyBBcGlDbGllbnRFcnJvcikubWVzc2FnZSkudG9CZSgnVmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICAgIGV4cGVjdCgoZXJyb3IgYXMgQXBpQ2xpZW50RXJyb3IpLmRldGFpbHMpLnRvRXF1YWwoZXJyb3JSZXNwb25zZS5lcnJvcnMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ29udGVudC1UeXBlIGhlYWRlciB0ZXN0XG4gIGl0KCdzaG91bGQgc2V0IGNvcnJlY3QgQ29udGVudC1UeXBlIGZvciBKU09OIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIGpzb246IGFzeW5jICgpID0+ICh7fSksXG4gICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICBhd2FpdCBjbGllbnQucG9zdCgnL3Rlc3QnLCB7IGRhdGE6ICd0ZXN0JyB9KTtcbiAgICBcbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICdodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpL3Rlc3QnLFxuICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICBoZWFkZXJzOiBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSksXG4gICAgICB9KVxuICAgICk7XG4gIH0pO1xuXG4gIC8vIEVtcHR5IHJlc3BvbnNlIGhhbmRsaW5nIHRlc3RcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgcmVzcG9uc2VzIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiBudWxsLFxuICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LmRlbGV0ZSgnL3Rlc3QvMScpO1xuICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gIH0pO1xuXG4gIC8vIEJhc2UgVVJMIGhhbmRsaW5nIHRlc3RcbiAgaXQoJ3Nob3VsZCBjb25zdHJ1Y3QgVVJMcyBjb3JyZWN0bHkgd2l0aCBiYXNlIFVSTCcsIGFzeW5jICgpID0+IHtcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiAoe30pLFxuICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgYXdhaXQgY2xpZW50LmdldCgnL2VuZHBvaW50Jyk7XG4gICAgXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAxL2FwaS9lbmRwb2ludCcsXG4gICAgICBleHBlY3QuYW55KE9iamVjdClcbiAgICApO1xuICB9KTtcblxuICAvLyBRdWVyeSBwYXJhbWV0ZXJzIHRlc3RcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgcXVlcnkgcGFyYW1ldGVycyBpbiBVUkxzJywgYXN5bmMgKCkgPT4ge1xuICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIGpzb246IGFzeW5jICgpID0+ICh7fSksXG4gICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICBhd2FpdCBjbGllbnQuZ2V0KCcvdGVzdD9wYXJhbTE9dmFsdWUxJnBhcmFtMj12YWx1ZTInKTtcbiAgICBcbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICdodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpL3Rlc3Q/cGFyYW0xPXZhbHVlMSZwYXJhbTI9dmFsdWUyJyxcbiAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KVxuICAgICk7XG4gIH0pO1xuXG4gIC8vIExvZ2dpbmcgdGVzdFxuICBpdCgnc2hvdWxkIGxvZyByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IGRhdGE6ICd0ZXN0JyB9KSxcbiAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgIGF3YWl0IGNsaWVudC5nZXQoJy90ZXN0Jyk7XG4gICAgXG4gICAgZXhwZWN0KGFwcExvZ2dlci5kZWJ1ZykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICB9KTtcblxuICAvLyBTaW5nbGV0b24gaW5zdGFuY2UgdGVzdFxuICBpdCgnc2hvdWxkIHByb3ZpZGUgc2luZ2xldG9uIGluc3RhbmNlJywgKCkgPT4ge1xuICAgIGV4cGVjdChhcGlDbGllbnQpLnRvQmVJbnN0YW5jZU9mKEFwaUNsaWVudCk7XG4gIH0pO1xuXG4gIC8vIEVycm9yIGNvZGUgbWFwcGluZyB0ZXN0XG4gIGl0KCdzaG91bGQgbWFwIEhUVFAgc3RhdHVzIGNvZGVzIHRvIGFwcHJvcHJpYXRlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB0ZXN0Q2FzZXMgPSBbXG4gICAgICB7IHN0YXR1czogNDAxLCBlcnJvclR5cGU6IEFwaUNsaWVudEVycm9yIH0sXG4gICAgICB7IHN0YXR1czogNDAzLCBlcnJvclR5cGU6IEFwaUNsaWVudEVycm9yIH0sXG4gICAgICB7IHN0YXR1czogNTAwLCBlcnJvclR5cGU6IEFwaUNsaWVudEVycm9yIH0sXG4gICAgXTtcblxuICAgIGZvciAoY29uc3QgdGVzdENhc2Ugb2YgdGVzdENhc2VzKSB7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IHRlc3RDYXNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogJ0Vycm9yJyxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgbWVzc2FnZTogJ0Vycm9yJyB9KSxcbiAgICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoY2xpZW50LmdldCgnL3Rlc3QnKSkucmVqZWN0cy50b1Rocm93KHRlc3RDYXNlLmVycm9yVHlwZSk7XG4gICAgfVxuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImFwcExvZ2dlciIsImRlYnVnIiwiZm4iLCJpbmZvIiwid2FybiIsImVycm9yIiwiZ2xvYmFsIiwiZmV0Y2giLCJkZXNjcmliZSIsImNsaWVudCIsIm1vY2tGZXRjaCIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiQXBpQ2xpZW50IiwiYWZ0ZXJFYWNoIiwicmVzZXRBbGxNb2NrcyIsIml0IiwiZXhwZWN0IiwidG9CZURlZmluZWQiLCJ0b0JlSW5zdGFuY2VPZiIsIm1vY2tEYXRhIiwiaWQiLCJuYW1lIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwib2siLCJzdGF0dXMiLCJqc29uIiwicmVzdWx0IiwiZ2V0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJvYmplY3RDb250YWluaW5nIiwibWV0aG9kIiwidG9FcXVhbCIsInBvc3REYXRhIiwicmVzcG9uc2VEYXRhIiwicG9zdCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicHV0RGF0YSIsInB1dCIsImRlbGV0ZSIsInNldEF1dGhUb2tlbiIsImhlYWRlcnMiLCJjbGVhckF1dGhUb2tlbiIsImNhbGxBcmdzIiwiY2FsbHMiLCJub3QiLCJ0b0hhdmVQcm9wZXJ0eSIsInN0YXR1c1RleHQiLCJtZXNzYWdlIiwicmVqZWN0cyIsInRvVGhyb3ciLCJBcGlDbGllbnRFcnJvciIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsIkVycm9yIiwiTmV0d29ya0Vycm9yIiwibW9ja0ltcGxlbWVudGF0aW9uT25jZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInNob3J0VGltZW91dENsaWVudCIsIlRpbWVvdXRFcnJvciIsImRhdGEiLCJlcnJvclJlc3BvbnNlIiwiZXJyb3JzIiwidG9CZSIsImRldGFpbHMiLCJ0b0JlTnVsbCIsImFueSIsIk9iamVjdCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJhcGlDbGllbnQiLCJ0ZXN0Q2FzZXMiLCJlcnJvclR5cGUiLCJ0ZXN0Q2FzZSJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDO0FBTUQsY0FBYztBQUNkQSxLQUFLQyxJQUFJLENBQUMsa0NBQWtDLElBQU8sQ0FBQTtRQUNqREMsV0FBVztZQUNUQyxPQUFPSCxLQUFLSSxFQUFFO1lBQ2RDLE1BQU1MLEtBQUtJLEVBQUU7WUFDYkUsTUFBTU4sS0FBS0ksRUFBRTtZQUNiRyxPQUFPUCxLQUFLSSxFQUFFO1FBQ2hCO0lBQ0YsQ0FBQTs7Ozs4QkFaMEI7d0JBRXVEO0FBWWpGLGFBQWE7QUFDYkksT0FBT0MsS0FBSyxHQUFHVCxLQUFLSSxFQUFFO0FBRXRCTSxTQUFTLGFBQWE7SUFD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