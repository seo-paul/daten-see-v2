e837d1e5232ddd12c759abd9f06498e3
/**
 * Data Sources API Service Tests
 * Testing data source CRUD operations and analytics queries
 */ "use strict";
// Mock the API client
jest.mock('../index', ()=>({
        apiClient: {
            get: jest.fn(),
            post: jest.fn(),
            put: jest.fn(),
            delete: jest.fn()
        },
        createQueryFunction: (fn)=>fn
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _datasources = require("../data-sources");
const _index = require("../index");
describe('DataSourceService', ()=>{
    const mockApiClient = _index.apiClient;
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('getDataSources', ()=>{
        const mockDataSources = [
            {
                id: 'ds-1',
                name: 'Production Database',
                type: 'postgresql',
                status: 'connected',
                workspaceId: 'ws-1',
                createdAt: new Date('2024-01-01'),
                updatedAt: new Date('2024-01-15'),
                config: {
                    host: 'db.example.com',
                    port: 5432,
                    database: 'production'
                }
            },
            {
                id: 'ds-2',
                name: 'Analytics API',
                type: 'rest-api',
                status: 'connected',
                workspaceId: 'ws-1',
                createdAt: new Date('2024-01-05'),
                updatedAt: new Date('2024-01-20'),
                config: {
                    baseUrl: 'https://api.analytics.com',
                    authType: 'bearer'
                }
            }
        ];
        it('should get all data sources without workspace filter', async ()=>{
            mockApiClient.get.mockResolvedValueOnce(mockDataSources);
            const result = await _datasources.DataSourceService.getDataSources();
            expect(mockApiClient.get).toHaveBeenCalledWith('/data-sources');
            expect(result).toEqual(mockDataSources);
        });
        it('should get data sources filtered by workspace', async ()=>{
            mockApiClient.get.mockResolvedValueOnce([
                mockDataSources[0]
            ]);
            const result = await _datasources.DataSourceService.getDataSources('ws-1');
            expect(mockApiClient.get).toHaveBeenCalledWith('/data-sources?workspaceId=ws-1');
            expect(result).toHaveLength(1);
            expect(result[0].workspaceId).toBe('ws-1');
        });
        it('should handle empty data sources', async ()=>{
            mockApiClient.get.mockResolvedValueOnce([]);
            const result = await _datasources.DataSourceService.getDataSources();
            expect(result).toEqual([]);
        });
        it('should handle API errors', async ()=>{
            mockApiClient.get.mockRejectedValueOnce(new Error('Network error'));
            await expect(_datasources.DataSourceService.getDataSources()).rejects.toThrow('Network error');
        });
    });
    describe('getDataSource', ()=>{
        const mockDataSource = {
            id: 'ds-1',
            name: 'Production Database',
            type: 'postgresql',
            status: 'connected',
            workspaceId: 'ws-1',
            createdAt: new Date('2024-01-01'),
            updatedAt: new Date('2024-01-15'),
            config: {
                host: 'db.example.com',
                port: 5432,
                database: 'production'
            }
        };
        it('should get single data source by ID', async ()=>{
            mockApiClient.get.mockResolvedValueOnce(mockDataSource);
            const result = await _datasources.DataSourceService.getDataSource('ds-1');
            expect(mockApiClient.get).toHaveBeenCalledWith('/data-sources/ds-1');
            expect(result).toEqual(mockDataSource);
        });
        it('should handle not found error', async ()=>{
            mockApiClient.get.mockRejectedValueOnce(new Error('Data source not found'));
            await expect(_datasources.DataSourceService.getDataSource('non-existent')).rejects.toThrow('Data source not found');
        });
    });
    describe('createDataSource', ()=>{
        const createRequest = {
            name: 'New Data Source',
            type: 'mysql',
            config: {
                host: 'localhost',
                port: 3306,
                database: 'test_db',
                username: 'test_user'
            },
            workspaceId: 'ws-1'
        };
        const mockCreatedDataSource = {
            id: 'ds-new',
            ...createRequest,
            status: 'connecting',
            createdAt: new Date(),
            updatedAt: new Date()
        };
        it('should create new data source', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: true,
                data: mockCreatedDataSource
            });
            const result = await _datasources.DataSourceService.createDataSource(createRequest);
            expect(mockApiClient.post).toHaveBeenCalledWith('/data-sources', createRequest);
            expect(result).toEqual(mockCreatedDataSource);
        });
        it('should handle creation failure', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: false,
                message: 'Invalid configuration'
            });
            await expect(_datasources.DataSourceService.createDataSource(createRequest)).rejects.toThrow('Invalid configuration');
        });
        it('should handle generic creation error', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: false
            });
            await expect(_datasources.DataSourceService.createDataSource(createRequest)).rejects.toThrow('Failed to create data source');
        });
        it('should create data source without workspace', async ()=>{
            const requestWithoutWorkspace = {
                name: 'Global Data Source',
                type: 'rest-api',
                config: {
                    baseUrl: 'https://api.example.com'
                }
            };
            mockApiClient.post.mockResolvedValueOnce({
                success: true,
                data: {
                    id: 'ds-global',
                    ...requestWithoutWorkspace,
                    status: 'connected',
                    createdAt: new Date(),
                    updatedAt: new Date()
                }
            });
            const result = await _datasources.DataSourceService.createDataSource(requestWithoutWorkspace);
            expect(result.workspaceId).toBeUndefined();
        });
    });
    describe('updateDataSource', ()=>{
        const updateRequest = {
            name: 'Updated Database',
            config: {
                host: 'new-db.example.com'
            }
        };
        const mockUpdatedDataSource = {
            id: 'ds-1',
            name: 'Updated Database',
            type: 'postgresql',
            status: 'connected',
            workspaceId: 'ws-1',
            createdAt: new Date('2024-01-01'),
            updatedAt: new Date(),
            config: {
                host: 'new-db.example.com',
                port: 5432,
                database: 'production'
            }
        };
        it('should update data source', async ()=>{
            mockApiClient.put.mockResolvedValueOnce({
                success: true,
                data: mockUpdatedDataSource
            });
            const result = await _datasources.DataSourceService.updateDataSource('ds-1', updateRequest);
            expect(mockApiClient.put).toHaveBeenCalledWith('/data-sources/ds-1', updateRequest);
            expect(result).toEqual(mockUpdatedDataSource);
        });
        it('should update only name', async ()=>{
            const nameOnlyUpdate = {
                name: 'Renamed Database'
            };
            mockApiClient.put.mockResolvedValueOnce({
                success: true,
                data: {
                    ...mockUpdatedDataSource,
                    name: 'Renamed Database'
                }
            });
            const result = await _datasources.DataSourceService.updateDataSource('ds-1', nameOnlyUpdate);
            expect(mockApiClient.put).toHaveBeenCalledWith('/data-sources/ds-1', nameOnlyUpdate);
            expect(result.name).toBe('Renamed Database');
        });
        it('should handle update failure', async ()=>{
            mockApiClient.put.mockResolvedValueOnce({
                success: false,
                message: 'Connection failed with new config'
            });
            await expect(_datasources.DataSourceService.updateDataSource('ds-1', updateRequest)).rejects.toThrow('Connection failed with new config');
        });
    });
    describe('deleteDataSource', ()=>{
        it('should delete data source', async ()=>{
            mockApiClient.delete.mockResolvedValueOnce({
                success: true
            });
            await expect(_datasources.DataSourceService.deleteDataSource('ds-1')).resolves.not.toThrow();
            expect(mockApiClient.delete).toHaveBeenCalledWith('/data-sources/ds-1');
        });
        it('should handle delete error', async ()=>{
            mockApiClient.delete.mockRejectedValueOnce(new Error('Cannot delete active data source'));
            await expect(_datasources.DataSourceService.deleteDataSource('ds-1')).rejects.toThrow('Cannot delete active data source');
        });
    });
    describe('testConnection', ()=>{
        it('should test successful connection', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: true,
                data: {
                    connected: true
                }
            });
            const result = await _datasources.DataSourceService.testConnection('ds-1');
            expect(mockApiClient.post).toHaveBeenCalledWith('/data-sources/ds-1/test');
            expect(result).toEqual({
                connected: true
            });
        });
        it('should test failed connection', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: true,
                data: {
                    connected: false,
                    error: 'ECONNREFUSED'
                }
            });
            const result = await _datasources.DataSourceService.testConnection('ds-1');
            expect(result).toEqual({
                connected: false,
                error: 'ECONNREFUSED'
            });
        });
        it('should handle test API error', async ()=>{
            mockApiClient.post.mockRejectedValueOnce(new Error('API error'));
            await expect(_datasources.DataSourceService.testConnection('ds-1')).rejects.toThrow('API error');
        });
    });
    describe('AnalyticsService.query', ()=>{
        const mockQuery = {
            dataSourceId: 'ds-1',
            query: 'SELECT * FROM users LIMIT 10',
            parameters: {}
        };
        const mockResponse = {
            success: true,
            data: {
                rows: [
                    {
                        id: 1,
                        name: 'User 1',
                        email: 'user1@example.com'
                    },
                    {
                        id: 2,
                        name: 'User 2',
                        email: 'user2@example.com'
                    }
                ],
                metadata: {
                    columns: [
                        'id',
                        'name',
                        'email'
                    ],
                    rowCount: 2,
                    executionTime: 45
                }
            }
        };
        it('should execute query successfully', async ()=>{
            mockApiClient.post.mockResolvedValueOnce(mockResponse);
            const result = await _datasources.AnalyticsService.query(mockQuery);
            expect(mockApiClient.post).toHaveBeenCalledWith('/analytics/query', mockQuery);
            expect(result).toEqual(mockResponse.data);
        });
        it('should execute query with parameters', async ()=>{
            const queryWithParams = {
                ...mockQuery,
                parameters: {
                    userId: 123,
                    startDate: '2024-01-01'
                }
            };
            mockApiClient.post.mockResolvedValueOnce(mockResponse);
            await _datasources.AnalyticsService.query(queryWithParams);
            expect(mockApiClient.post).toHaveBeenCalledWith('/analytics/query', queryWithParams);
        });
        it('should handle query execution error', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: false,
                message: 'Syntax error in SQL query'
            });
            await expect(_datasources.AnalyticsService.query(mockQuery)).rejects.toThrow('Syntax error in SQL query');
        });
        it('should handle empty query results', async ()=>{
            mockApiClient.post.mockResolvedValueOnce({
                success: true,
                data: {
                    rows: [],
                    metadata: {
                        columns: [],
                        rowCount: 0,
                        executionTime: 10
                    }
                }
            });
            const result = await _datasources.AnalyticsService.query(mockQuery);
            expect(result.rows).toHaveLength(0);
            expect(result.metadata.rowCount).toBe(0);
        });
    });
    describe('getAvailableMetrics and getAvailableDimensions', ()=>{
        const mockMetrics = [
            'revenue',
            'users',
            'sessions',
            'pageviews'
        ];
        const mockDimensions = [
            'country',
            'device',
            'browser',
            'page'
        ];
        it('should get available metrics', async ()=>{
            mockApiClient.get.mockResolvedValueOnce(mockMetrics);
            const result = await _datasources.DataSourceService.getAvailableMetrics('ds-1');
            expect(mockApiClient.get).toHaveBeenCalledWith('/data-sources/ds-1/metrics');
            expect(result).toEqual(mockMetrics);
        });
        it('should get available dimensions', async ()=>{
            mockApiClient.get.mockResolvedValueOnce(mockDimensions);
            const result = await _datasources.DataSourceService.getAvailableDimensions('ds-1');
            expect(mockApiClient.get).toHaveBeenCalledWith('/data-sources/ds-1/dimensions');
            expect(result).toEqual(mockDimensions);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy96d2VpZ2VuL1NpdGVzL2RhdGVuLXNlZS12Mi9zcmMvbGliL2FwaS9fX3Rlc3RzX18vZGF0YS1zb3VyY2VzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEYXRhIFNvdXJjZXMgQVBJIFNlcnZpY2UgVGVzdHNcbiAqIFRlc3RpbmcgZGF0YSBzb3VyY2UgQ1JVRCBvcGVyYXRpb25zIGFuZCBhbmFseXRpY3MgcXVlcmllc1xuICovXG5cbmltcG9ydCB0eXBlIHsgRGF0YVNvdXJjZSwgRGF0YVNvdXJjZVR5cGUsIEFuYWx5dGljc1F1ZXJ5IH0gZnJvbSAnQC90eXBlcyc7XG5cbmltcG9ydCB7IERhdGFTb3VyY2VTZXJ2aWNlLCBBbmFseXRpY3NTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0YS1zb3VyY2VzJztcbmltcG9ydCB7IGFwaUNsaWVudCB9IGZyb20gJy4uL2luZGV4JztcblxuLy8gTW9jayB0aGUgQVBJIGNsaWVudFxuamVzdC5tb2NrKCcuLi9pbmRleCcsICgpID0+ICh7XG4gIGFwaUNsaWVudDoge1xuICAgIGdldDogamVzdC5mbigpLFxuICAgIHBvc3Q6IGplc3QuZm4oKSxcbiAgICBwdXQ6IGplc3QuZm4oKSxcbiAgICBkZWxldGU6IGplc3QuZm4oKSxcbiAgfSxcbiAgY3JlYXRlUXVlcnlGdW5jdGlvbjogKGZuOiBGdW5jdGlvbikgPT4gZm4sXG59KSk7XG5cbmRlc2NyaWJlKCdEYXRhU291cmNlU2VydmljZScsICgpID0+IHtcbiAgY29uc3QgbW9ja0FwaUNsaWVudCA9IGFwaUNsaWVudCBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgYXBpQ2xpZW50PjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldERhdGFTb3VyY2VzJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tEYXRhU291cmNlczogRGF0YVNvdXJjZVtdID0gW1xuICAgICAge1xuICAgICAgICBpZDogJ2RzLTEnLFxuICAgICAgICBuYW1lOiAnUHJvZHVjdGlvbiBEYXRhYmFzZScsXG4gICAgICAgIHR5cGU6ICdwb3N0Z3Jlc3FsJyxcbiAgICAgICAgc3RhdHVzOiAnY29ubmVjdGVkJyxcbiAgICAgICAgd29ya3NwYWNlSWQ6ICd3cy0xJyxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgnMjAyNC0wMS0wMScpLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTE1JyksXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgIGhvc3Q6ICdkYi5leGFtcGxlLmNvbScsXG4gICAgICAgICAgcG9ydDogNTQzMixcbiAgICAgICAgICBkYXRhYmFzZTogJ3Byb2R1Y3Rpb24nLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdkcy0yJyxcbiAgICAgICAgbmFtZTogJ0FuYWx5dGljcyBBUEknLFxuICAgICAgICB0eXBlOiAncmVzdC1hcGknLFxuICAgICAgICBzdGF0dXM6ICdjb25uZWN0ZWQnLFxuICAgICAgICB3b3Jrc3BhY2VJZDogJ3dzLTEnLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTA1JyksXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoJzIwMjQtMDEtMjAnKSxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgYmFzZVVybDogJ2h0dHBzOi8vYXBpLmFuYWx5dGljcy5jb20nLFxuICAgICAgICAgIGF1dGhUeXBlOiAnYmVhcmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGl0KCdzaG91bGQgZ2V0IGFsbCBkYXRhIHNvdXJjZXMgd2l0aG91dCB3b3Jrc3BhY2UgZmlsdGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0FwaUNsaWVudC5nZXQubW9ja1Jlc29sdmVkVmFsdWVPbmNlKG1vY2tEYXRhU291cmNlcyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IERhdGFTb3VyY2VTZXJ2aWNlLmdldERhdGFTb3VyY2VzKCk7XG5cbiAgICAgIGV4cGVjdChtb2NrQXBpQ2xpZW50LmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9kYXRhLXNvdXJjZXMnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja0RhdGFTb3VyY2VzKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZ2V0IGRhdGEgc291cmNlcyBmaWx0ZXJlZCBieSB3b3Jrc3BhY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LmdldC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoW21vY2tEYXRhU291cmNlc1swXV0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBEYXRhU291cmNlU2VydmljZS5nZXREYXRhU291cmNlcygnd3MtMScpO1xuXG4gICAgICBleHBlY3QobW9ja0FwaUNsaWVudC5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvZGF0YS1zb3VyY2VzP3dvcmtzcGFjZUlkPXdzLTEnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHRbMF0ud29ya3NwYWNlSWQpLnRvQmUoJ3dzLTEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IGRhdGEgc291cmNlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBcGlDbGllbnQuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZShbXSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IERhdGFTb3VyY2VTZXJ2aWNlLmdldERhdGFTb3VyY2VzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgQVBJIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBcGlDbGllbnQuZ2V0Lm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ05ldHdvcmsgZXJyb3InKSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChEYXRhU291cmNlU2VydmljZS5nZXREYXRhU291cmNlcygpKS5yZWplY3RzLnRvVGhyb3coJ05ldHdvcmsgZXJyb3InKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldERhdGFTb3VyY2UnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0RhdGFTb3VyY2U6IERhdGFTb3VyY2UgPSB7XG4gICAgICBpZDogJ2RzLTEnLFxuICAgICAgbmFtZTogJ1Byb2R1Y3Rpb24gRGF0YWJhc2UnLFxuICAgICAgdHlwZTogJ3Bvc3RncmVzcWwnLFxuICAgICAgc3RhdHVzOiAnY29ubmVjdGVkJyxcbiAgICAgIHdvcmtzcGFjZUlkOiAnd3MtMScsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTAxJyksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTE1JyksXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgaG9zdDogJ2RiLmV4YW1wbGUuY29tJyxcbiAgICAgICAgcG9ydDogNTQzMixcbiAgICAgICAgZGF0YWJhc2U6ICdwcm9kdWN0aW9uJyxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGl0KCdzaG91bGQgZ2V0IHNpbmdsZSBkYXRhIHNvdXJjZSBieSBJRCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBcGlDbGllbnQuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZShtb2NrRGF0YVNvdXJjZSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IERhdGFTb3VyY2VTZXJ2aWNlLmdldERhdGFTb3VyY2UoJ2RzLTEnKTtcblxuICAgICAgZXhwZWN0KG1vY2tBcGlDbGllbnQuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2RhdGEtc291cmNlcy9kcy0xJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tEYXRhU291cmNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5vdCBmb3VuZCBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBcGlDbGllbnQuZ2V0Lm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ0RhdGEgc291cmNlIG5vdCBmb3VuZCcpKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KERhdGFTb3VyY2VTZXJ2aWNlLmdldERhdGFTb3VyY2UoJ25vbi1leGlzdGVudCcpKS5yZWplY3RzLnRvVGhyb3coJ0RhdGEgc291cmNlIG5vdCBmb3VuZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY3JlYXRlRGF0YVNvdXJjZScsICgpID0+IHtcbiAgICBjb25zdCBjcmVhdGVSZXF1ZXN0ID0ge1xuICAgICAgbmFtZTogJ05ldyBEYXRhIFNvdXJjZScsXG4gICAgICB0eXBlOiAnbXlzcWwnIGFzIERhdGFTb3VyY2VUeXBlLFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIGhvc3Q6ICdsb2NhbGhvc3QnLFxuICAgICAgICBwb3J0OiAzMzA2LFxuICAgICAgICBkYXRhYmFzZTogJ3Rlc3RfZGInLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3RfdXNlcicsXG4gICAgICB9LFxuICAgICAgd29ya3NwYWNlSWQ6ICd3cy0xJyxcbiAgICB9O1xuXG4gICAgY29uc3QgbW9ja0NyZWF0ZWREYXRhU291cmNlOiBEYXRhU291cmNlID0ge1xuICAgICAgaWQ6ICdkcy1uZXcnLFxuICAgICAgLi4uY3JlYXRlUmVxdWVzdCxcbiAgICAgIHN0YXR1czogJ2Nvbm5lY3RpbmcnLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBuZXcgZGF0YSBzb3VyY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogbW9ja0NyZWF0ZWREYXRhU291cmNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IERhdGFTb3VyY2VTZXJ2aWNlLmNyZWF0ZURhdGFTb3VyY2UoY3JlYXRlUmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChtb2NrQXBpQ2xpZW50LnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvZGF0YS1zb3VyY2VzJywgY3JlYXRlUmVxdWVzdCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tDcmVhdGVkRGF0YVNvdXJjZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjcmVhdGlvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0FwaUNsaWVudC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBjb25maWd1cmF0aW9uJyxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QoRGF0YVNvdXJjZVNlcnZpY2UuY3JlYXRlRGF0YVNvdXJjZShjcmVhdGVSZXF1ZXN0KSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnSW52YWxpZCBjb25maWd1cmF0aW9uJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBnZW5lcmljIGNyZWF0aW9uIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0FwaUNsaWVudC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChEYXRhU291cmNlU2VydmljZS5jcmVhdGVEYXRhU291cmNlKGNyZWF0ZVJlcXVlc3QpKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdGYWlsZWQgdG8gY3JlYXRlIGRhdGEgc291cmNlJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBkYXRhIHNvdXJjZSB3aXRob3V0IHdvcmtzcGFjZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RXaXRob3V0V29ya3NwYWNlID0ge1xuICAgICAgICBuYW1lOiAnR2xvYmFsIERhdGEgU291cmNlJyxcbiAgICAgICAgdHlwZTogJ3Jlc3QtYXBpJyBhcyBEYXRhU291cmNlVHlwZSxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgYmFzZVVybDogJ2h0dHBzOi8vYXBpLmV4YW1wbGUuY29tJyxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tBcGlDbGllbnQucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6ICdkcy1nbG9iYWwnLFxuICAgICAgICAgIC4uLnJlcXVlc3RXaXRob3V0V29ya3NwYWNlLFxuICAgICAgICAgIHN0YXR1czogJ2Nvbm5lY3RlZCcsXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBEYXRhU291cmNlU2VydmljZS5jcmVhdGVEYXRhU291cmNlKHJlcXVlc3RXaXRob3V0V29ya3NwYWNlKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC53b3Jrc3BhY2VJZCkudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndXBkYXRlRGF0YVNvdXJjZScsICgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVSZXF1ZXN0ID0ge1xuICAgICAgbmFtZTogJ1VwZGF0ZWQgRGF0YWJhc2UnLFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIGhvc3Q6ICduZXctZGIuZXhhbXBsZS5jb20nLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgbW9ja1VwZGF0ZWREYXRhU291cmNlOiBEYXRhU291cmNlID0ge1xuICAgICAgaWQ6ICdkcy0xJyxcbiAgICAgIG5hbWU6ICdVcGRhdGVkIERhdGFiYXNlJyxcbiAgICAgIHR5cGU6ICdwb3N0Z3Jlc3FsJyxcbiAgICAgIHN0YXR1czogJ2Nvbm5lY3RlZCcsXG4gICAgICB3b3Jrc3BhY2VJZDogJ3dzLTEnLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgnMjAyNC0wMS0wMScpLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIGhvc3Q6ICduZXctZGIuZXhhbXBsZS5jb20nLFxuICAgICAgICBwb3J0OiA1NDMyLFxuICAgICAgICBkYXRhYmFzZTogJ3Byb2R1Y3Rpb24nLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgZGF0YSBzb3VyY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LnB1dC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiBtb2NrVXBkYXRlZERhdGFTb3VyY2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgRGF0YVNvdXJjZVNlcnZpY2UudXBkYXRlRGF0YVNvdXJjZSgnZHMtMScsIHVwZGF0ZVJlcXVlc3QpO1xuXG4gICAgICBleHBlY3QobW9ja0FwaUNsaWVudC5wdXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvZGF0YS1zb3VyY2VzL2RzLTEnLCB1cGRhdGVSZXF1ZXN0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1VwZGF0ZWREYXRhU291cmNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXBkYXRlIG9ubHkgbmFtZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG5hbWVPbmx5VXBkYXRlID0geyBuYW1lOiAnUmVuYW1lZCBEYXRhYmFzZScgfTtcbiAgICAgIFxuICAgICAgbW9ja0FwaUNsaWVudC5wdXQubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogeyAuLi5tb2NrVXBkYXRlZERhdGFTb3VyY2UsIG5hbWU6ICdSZW5hbWVkIERhdGFiYXNlJyB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IERhdGFTb3VyY2VTZXJ2aWNlLnVwZGF0ZURhdGFTb3VyY2UoJ2RzLTEnLCBuYW1lT25seVVwZGF0ZSk7XG5cbiAgICAgIGV4cGVjdChtb2NrQXBpQ2xpZW50LnB1dCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9kYXRhLXNvdXJjZXMvZHMtMScsIG5hbWVPbmx5VXBkYXRlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubmFtZSkudG9CZSgnUmVuYW1lZCBEYXRhYmFzZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdXBkYXRlIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LnB1dC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gZmFpbGVkIHdpdGggbmV3IGNvbmZpZycsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KERhdGFTb3VyY2VTZXJ2aWNlLnVwZGF0ZURhdGFTb3VyY2UoJ2RzLTEnLCB1cGRhdGVSZXF1ZXN0KSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnQ29ubmVjdGlvbiBmYWlsZWQgd2l0aCBuZXcgY29uZmlnJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdkZWxldGVEYXRhU291cmNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZGVsZXRlIGRhdGEgc291cmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0FwaUNsaWVudC5kZWxldGUubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgc3VjY2VzczogdHJ1ZSB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KERhdGFTb3VyY2VTZXJ2aWNlLmRlbGV0ZURhdGFTb3VyY2UoJ2RzLTEnKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcblxuICAgICAgZXhwZWN0KG1vY2tBcGlDbGllbnQuZGVsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2RhdGEtc291cmNlcy9kcy0xJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkZWxldGUgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LmRlbGV0ZS5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdDYW5ub3QgZGVsZXRlIGFjdGl2ZSBkYXRhIHNvdXJjZScpKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KERhdGFTb3VyY2VTZXJ2aWNlLmRlbGV0ZURhdGFTb3VyY2UoJ2RzLTEnKSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnQ2Fubm90IGRlbGV0ZSBhY3RpdmUgZGF0YSBzb3VyY2UnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3Rlc3RDb25uZWN0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdGVzdCBzdWNjZXNzZnVsIGNvbm5lY3Rpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBEYXRhU291cmNlU2VydmljZS50ZXN0Q29ubmVjdGlvbignZHMtMScpO1xuXG4gICAgICBleHBlY3QobW9ja0FwaUNsaWVudC5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2RhdGEtc291cmNlcy9kcy0xL3Rlc3QnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGVzdCBmYWlsZWQgY29ubmVjdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBcGlDbGllbnQucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogJ0VDT05OUkVGVVNFRCcsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgRGF0YVNvdXJjZVNlcnZpY2UudGVzdENvbm5lY3Rpb24oJ2RzLTEnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIGNvbm5lY3RlZDogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnRUNPTk5SRUZVU0VEJyxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdGVzdCBBUEkgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LnBvc3QubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignQVBJIGVycm9yJykpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoRGF0YVNvdXJjZVNlcnZpY2UudGVzdENvbm5lY3Rpb24oJ2RzLTEnKSkucmVqZWN0cy50b1Rocm93KCdBUEkgZXJyb3InKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FuYWx5dGljc1NlcnZpY2UucXVlcnknLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1F1ZXJ5OiBBbmFseXRpY3NRdWVyeSA9IHtcbiAgICAgIGRhdGFTb3VyY2VJZDogJ2RzLTEnLFxuICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIHVzZXJzIExJTUlUIDEwJyxcbiAgICAgIHBhcmFtZXRlcnM6IHt9LFxuICAgIH07XG5cbiAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YToge1xuICAgICAgICByb3dzOiBbXG4gICAgICAgICAgeyBpZDogMSwgbmFtZTogJ1VzZXIgMScsIGVtYWlsOiAndXNlcjFAZXhhbXBsZS5jb20nIH0sXG4gICAgICAgICAgeyBpZDogMiwgbmFtZTogJ1VzZXIgMicsIGVtYWlsOiAndXNlcjJAZXhhbXBsZS5jb20nIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgY29sdW1uczogWydpZCcsICduYW1lJywgJ2VtYWlsJ10sXG4gICAgICAgICAgcm93Q291bnQ6IDIsXG4gICAgICAgICAgZXhlY3V0aW9uVGltZTogNDUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIGV4ZWN1dGUgcXVlcnkgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0FwaUNsaWVudC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZShtb2NrUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBBbmFseXRpY3NTZXJ2aWNlLnF1ZXJ5KG1vY2tRdWVyeSk7XG5cbiAgICAgIGV4cGVjdChtb2NrQXBpQ2xpZW50LnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvYW5hbHl0aWNzL3F1ZXJ5JywgbW9ja1F1ZXJ5KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1Jlc3BvbnNlLmRhdGEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBleGVjdXRlIHF1ZXJ5IHdpdGggcGFyYW1ldGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHF1ZXJ5V2l0aFBhcmFtcyA9IHtcbiAgICAgICAgLi4ubW9ja1F1ZXJ5LFxuICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgdXNlcklkOiAxMjMsXG4gICAgICAgICAgc3RhcnREYXRlOiAnMjAyNC0wMS0wMScsXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBtb2NrQXBpQ2xpZW50LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKG1vY2tSZXNwb25zZSk7XG5cbiAgICAgIGF3YWl0IEFuYWx5dGljc1NlcnZpY2UucXVlcnkocXVlcnlXaXRoUGFyYW1zKTtcblxuICAgICAgZXhwZWN0KG1vY2tBcGlDbGllbnQucG9zdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hbmFseXRpY3MvcXVlcnknLCBxdWVyeVdpdGhQYXJhbXMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcXVlcnkgZXhlY3V0aW9uIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0FwaUNsaWVudC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBtZXNzYWdlOiAnU3ludGF4IGVycm9yIGluIFNRTCBxdWVyeScsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KEFuYWx5dGljc1NlcnZpY2UucXVlcnkobW9ja1F1ZXJ5KSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnU3ludGF4IGVycm9yIGluIFNRTCBxdWVyeScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgcXVlcnkgcmVzdWx0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBcGlDbGllbnQucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcm93czogW10sXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIGNvbHVtbnM6IFtdLFxuICAgICAgICAgICAgcm93Q291bnQ6IDAsXG4gICAgICAgICAgICBleGVjdXRpb25UaW1lOiAxMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEFuYWx5dGljc1NlcnZpY2UucXVlcnkobW9ja1F1ZXJ5KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5yb3dzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1ldGFkYXRhLnJvd0NvdW50KS50b0JlKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0QXZhaWxhYmxlTWV0cmljcyBhbmQgZ2V0QXZhaWxhYmxlRGltZW5zaW9ucycsICgpID0+IHtcbiAgICBjb25zdCBtb2NrTWV0cmljcyA9IFsncmV2ZW51ZScsICd1c2VycycsICdzZXNzaW9ucycsICdwYWdldmlld3MnXTtcbiAgICBjb25zdCBtb2NrRGltZW5zaW9ucyA9IFsnY291bnRyeScsICdkZXZpY2UnLCAnYnJvd3NlcicsICdwYWdlJ107XG5cbiAgICBpdCgnc2hvdWxkIGdldCBhdmFpbGFibGUgbWV0cmljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBcGlDbGllbnQuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZShtb2NrTWV0cmljcyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IERhdGFTb3VyY2VTZXJ2aWNlLmdldEF2YWlsYWJsZU1ldHJpY3MoJ2RzLTEnKTtcblxuICAgICAgZXhwZWN0KG1vY2tBcGlDbGllbnQuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2RhdGEtc291cmNlcy9kcy0xL21ldHJpY3MnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja01ldHJpY3MpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBnZXQgYXZhaWxhYmxlIGRpbWVuc2lvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpQ2xpZW50LmdldC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UobW9ja0RpbWVuc2lvbnMpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBEYXRhU291cmNlU2VydmljZS5nZXRBdmFpbGFibGVEaW1lbnNpb25zKCdkcy0xJyk7XG5cbiAgICAgIGV4cGVjdChtb2NrQXBpQ2xpZW50LmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9kYXRhLXNvdXJjZXMvZHMtMS9kaW1lbnNpb25zJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tEaW1lbnNpb25zKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJhcGlDbGllbnQiLCJnZXQiLCJmbiIsInBvc3QiLCJwdXQiLCJkZWxldGUiLCJjcmVhdGVRdWVyeUZ1bmN0aW9uIiwiZGVzY3JpYmUiLCJtb2NrQXBpQ2xpZW50IiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrRGF0YVNvdXJjZXMiLCJpZCIsIm5hbWUiLCJ0eXBlIiwic3RhdHVzIiwid29ya3NwYWNlSWQiLCJjcmVhdGVkQXQiLCJEYXRlIiwidXBkYXRlZEF0IiwiY29uZmlnIiwiaG9zdCIsInBvcnQiLCJkYXRhYmFzZSIsImJhc2VVcmwiLCJhdXRoVHlwZSIsIml0IiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwicmVzdWx0IiwiRGF0YVNvdXJjZVNlcnZpY2UiLCJnZXREYXRhU291cmNlcyIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwidG9FcXVhbCIsInRvSGF2ZUxlbmd0aCIsInRvQmUiLCJtb2NrUmVqZWN0ZWRWYWx1ZU9uY2UiLCJFcnJvciIsInJlamVjdHMiLCJ0b1Rocm93IiwibW9ja0RhdGFTb3VyY2UiLCJnZXREYXRhU291cmNlIiwiY3JlYXRlUmVxdWVzdCIsInVzZXJuYW1lIiwibW9ja0NyZWF0ZWREYXRhU291cmNlIiwic3VjY2VzcyIsImRhdGEiLCJjcmVhdGVEYXRhU291cmNlIiwibWVzc2FnZSIsInJlcXVlc3RXaXRob3V0V29ya3NwYWNlIiwidG9CZVVuZGVmaW5lZCIsInVwZGF0ZVJlcXVlc3QiLCJtb2NrVXBkYXRlZERhdGFTb3VyY2UiLCJ1cGRhdGVEYXRhU291cmNlIiwibmFtZU9ubHlVcGRhdGUiLCJkZWxldGVEYXRhU291cmNlIiwicmVzb2x2ZXMiLCJub3QiLCJjb25uZWN0ZWQiLCJ0ZXN0Q29ubmVjdGlvbiIsImVycm9yIiwibW9ja1F1ZXJ5IiwiZGF0YVNvdXJjZUlkIiwicXVlcnkiLCJwYXJhbWV0ZXJzIiwibW9ja1Jlc3BvbnNlIiwicm93cyIsImVtYWlsIiwibWV0YWRhdGEiLCJjb2x1bW5zIiwicm93Q291bnQiLCJleGVjdXRpb25UaW1lIiwiQW5hbHl0aWNzU2VydmljZSIsInF1ZXJ5V2l0aFBhcmFtcyIsInVzZXJJZCIsInN0YXJ0RGF0ZSIsIm1vY2tNZXRyaWNzIiwibW9ja0RpbWVuc2lvbnMiLCJnZXRBdmFpbGFibGVNZXRyaWNzIiwiZ2V0QXZhaWxhYmxlRGltZW5zaW9ucyJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDO0FBT0Qsc0JBQXNCO0FBQ3RCQSxLQUFLQyxJQUFJLENBQUMsWUFBWSxJQUFPLENBQUE7UUFDM0JDLFdBQVc7WUFDVEMsS0FBS0gsS0FBS0ksRUFBRTtZQUNaQyxNQUFNTCxLQUFLSSxFQUFFO1lBQ2JFLEtBQUtOLEtBQUtJLEVBQUU7WUFDWkcsUUFBUVAsS0FBS0ksRUFBRTtRQUNqQjtRQUNBSSxxQkFBcUIsQ0FBQ0osS0FBaUJBO0lBQ3pDLENBQUE7Ozs7NkJBWm9EO3VCQUMxQjtBQWExQkssU0FBUyxxQkFBcUI7SUFDNUIsTUFBTUMsZ0JBQWdCUixnQkFBUztJQUUvQlMsV0FBVztRQUNUWCxLQUFLWSxhQUFhO0lBQ3BCO0lBRUFILFNBQVMsa0JBQWtCO1FBQ3pCLE1BQU1JLGtCQUFnQztZQUNwQztnQkFDRUMsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsV0FBVyxJQUFJQyxLQUFLO2dCQUNwQkMsV0FBVyxJQUFJRCxLQUFLO2dCQUNwQkUsUUFBUTtv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