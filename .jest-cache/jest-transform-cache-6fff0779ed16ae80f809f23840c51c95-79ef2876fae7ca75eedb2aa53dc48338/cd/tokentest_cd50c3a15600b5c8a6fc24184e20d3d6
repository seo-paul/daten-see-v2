707aebb54672c2c31bf2faae6ab1ad28
/**
 * Token Manager Tests - JWT Security (95% Coverage Target)
 * Critical business logic for authentication and authorization
 * 
 * Test Categories:
 * 1. Token Storage & Retrieval Operations
 * 2. Expiration Validation & Refresh Logic  
 * 3. JWT Payload Parsing & User Info Extraction
 * 4. API Client Integration
 * 5. Security Edge Cases & Error Handling
 * 6. Server-Side vs Client-Side Behavior
 */ "use strict";
// Mock logger to avoid console noise in tests (allowing actual logging for debugging)
jest.mock('@/lib/monitoring/logger.config', ()=>({
        appLogger: {
            debug: jest.fn(),
            warn: jest.fn(),
            error: jest.fn(),
            info: jest.fn()
        }
    }));
// Mock API client to avoid circular dependencies
jest.mock('@/lib/api/client', ()=>({
        apiClient: {
            setAuthToken: jest.fn(),
            clearAuthToken: jest.fn()
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _token = require("../token");
describe('TokenManager - JWT Security Tests (95% Coverage)', ()=>{
    // Test data
    const validTokenData = {
        token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyLTEiLCJlbWFpbCI6InRlc3RAZXhhbXBsZS5jb20iLCJyb2xlIjoiYWRtaW4iLCJleHAiOjE3MDAwMDAwMDAsImlhdCI6MTY5OTk5OTAwMH0.test-signature',
        refreshToken: 'refresh-token-123',
        expiresAt: new Date(Date.now() + 3600000).toISOString()
    };
    const expiredTokenData = {
        token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyLTEiLCJlbWFpbCI6InRlc3RAZXhhbXBsZS5jb20iLCJyb2xlIjoiYWRtaW4iLCJleHAiOjE2MDAwMDAwMDAsImlhdCI6MTU5OTk5OTAwMH0.test-signature',
        refreshToken: 'refresh-token-expired',
        expiresAt: new Date(Date.now() - 3600000).toISOString()
    };
    // Mock localStorage
    const localStorageMock = {
        getItem: jest.fn(),
        setItem: jest.fn(),
        removeItem: jest.fn(),
        clear: jest.fn()
    };
    const originalWindow = global.window;
    const originalLocalStorage = global.localStorage;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock window and localStorage for client-side tests
        Object.defineProperty(global, 'window', {
            value: {
                localStorage: localStorageMock
            },
            writable: true,
            configurable: true
        });
        Object.defineProperty(global, 'localStorage', {
            value: localStorageMock,
            writable: true,
            configurable: true
        });
    });
    afterEach(()=>{
        // Restore original window
        if (originalWindow) {
            global.window = originalWindow;
        } else {
            delete global.window;
        }
        global.localStorage = originalLocalStorage;
    });
    describe('Token Storage Operations', ()=>{
        it('should store tokens successfully on client side', ()=>{
            _token.tokenManager.setTokens(validTokenData);
            expect(localStorageMock.setItem).toHaveBeenCalledWith('auth_token', validTokenData.token);
            expect(localStorageMock.setItem).toHaveBeenCalledWith('refresh_token', validTokenData.refreshToken);
            expect(localStorageMock.setItem).toHaveBeenCalledWith('token_expiry', validTokenData.expiresAt);
        });
        it('should handle server side gracefully', ()=>{
            // Since TokenManager is a singleton, isClient is set once at module load
            // This test verifies the method doesn't throw rather than testing the exact server behavior
            expect(()=>_token.tokenManager.setTokens(validTokenData)).not.toThrow();
        // The actual server-side behavior would be tested in a fresh Node.js environment
        // where window is undefined from the start
        });
        it('should handle localStorage errors during storage', ()=>{
            localStorageMock.setItem.mockImplementation(()=>{
                throw new Error('Storage quota exceeded');
            });
            expect(()=>_token.tokenManager.setTokens(validTokenData)).toThrow('Token storage failed');
        });
        it('should clear all tokens successfully', ()=>{
            _token.tokenManager.clearTokens();
            expect(localStorageMock.removeItem).toHaveBeenCalledWith('auth_token');
            expect(localStorageMock.removeItem).toHaveBeenCalledWith('refresh_token');
            expect(localStorageMock.removeItem).toHaveBeenCalledWith('token_expiry');
        });
        it('should handle localStorage errors during clearing', ()=>{
            localStorageMock.removeItem.mockImplementation(()=>{
                throw new Error('localStorage access denied');
            });
            // Should not throw, just log error
            expect(()=>_token.tokenManager.clearTokens()).not.toThrow();
        });
        it('should handle server side clearing gracefully', ()=>{
            // Similar to storage, since TokenManager is a singleton, this tests graceful handling
            expect(()=>_token.tokenManager.clearTokens()).not.toThrow();
        });
    });
    describe('Token Retrieval & Validation', ()=>{
        it('should retrieve valid token info', ()=>{
            localStorageMock.getItem.mockReturnValueOnce(validTokenData.token).mockReturnValueOnce(validTokenData.refreshToken).mockReturnValueOnce(validTokenData.expiresAt);
            const tokenInfo = _token.tokenManager.getTokenInfo();
            expect(tokenInfo).toEqual({
                token: validTokenData.token,
                refreshToken: validTokenData.refreshToken,
                expiresAt: new Date(validTokenData.expiresAt),
                isValid: true,
                isExpired: false
            });
        });
        it('should handle expired tokens correctly', ()=>{
            localStorageMock.getItem.mockReturnValueOnce(expiredTokenData.token).mockReturnValueOnce(expiredTokenData.refreshToken).mockReturnValueOnce(expiredTokenData.expiresAt);
            const tokenInfo = _token.tokenManager.getTokenInfo();
            expect(tokenInfo).toEqual({
                token: expiredTokenData.token,
                refreshToken: expiredTokenData.refreshToken,
                expiresAt: new Date(expiredTokenData.expiresAt),
                isValid: false,
                isExpired: true
            });
        });
        it('should handle missing tokens', ()=>{
            localStorageMock.getItem.mockReturnValue(null);
            const tokenInfo = _token.tokenManager.getTokenInfo();
            expect(tokenInfo).toEqual({
                token: null,
                refreshToken: null,
                expiresAt: null,
                isValid: false,
                isExpired: true
            });
        });
        it('should handle invalid expiry date format', ()=>{
            localStorageMock.getItem.mockReturnValueOnce(validTokenData.token).mockReturnValueOnce(validTokenData.refreshToken).mockReturnValueOnce('invalid-date');
            const tokenInfo = _token.tokenManager.getTokenInfo();
            // Test current behavior: invalid date string creates a Date object but represents Invalid Date
            expect(tokenInfo.expiresAt).toBeInstanceOf(Date);
            // JavaScript Date('invalid-date') creates a Date that isNaN but still truthy
            const isInvalidDate = isNaN(tokenInfo.expiresAt.getTime());
            expect(isInvalidDate).toBe(true); // The date should be invalid
            // Current implementation doesn't check for invalid dates in the isValid logic
            // This test documents the current behavior - could be improved in future
            // For now, we test that it doesn't crash and returns a consistent structure
            expect(typeof tokenInfo.isValid).toBe('boolean');
            expect(typeof tokenInfo.isExpired).toBe('boolean');
        });
        it('should handle server side token retrieval gracefully', ()=>{
            // Since TokenManager is a singleton, this tests graceful handling rather than true server behavior
            const tokenInfo = _token.tokenManager.getTokenInfo();
            // The method should not throw and should return a valid TokenInfo structure
            expect(tokenInfo).toHaveProperty('token');
            expect(tokenInfo).toHaveProperty('refreshToken');
            expect(tokenInfo).toHaveProperty('expiresAt');
            expect(tokenInfo).toHaveProperty('isValid');
            expect(tokenInfo).toHaveProperty('isExpired');
        });
        it('should handle localStorage errors during retrieval', ()=>{
            localStorageMock.getItem.mockImplementation(()=>{
                throw new Error('localStorage access denied');
            });
            const tokenInfo = _token.tokenManager.getTokenInfo();
            expect(tokenInfo.isValid).toBe(false);
        });
        it('should get access token when valid', ()=>{
            localStorageMock.getItem.mockReturnValueOnce(validTokenData.token).mockReturnValueOnce(validTokenData.refreshToken).mockReturnValueOnce(validTokenData.expiresAt);
            const accessToken = _token.tokenManager.getAccessToken();
            expect(accessToken).toBe(validTokenData.token);
        });
        it('should return null access token when invalid', ()=>{
            localStorageMock.getItem.mockReturnValue(null);
            const accessToken = _token.tokenManager.getAccessToken();
            expect(accessToken).toBeNull();
        });
        it('should get refresh token when available', ()=>{
            localStorageMock.getItem.mockReturnValueOnce(validTokenData.token).mockReturnValueOnce(validTokenData.refreshToken).mockReturnValueOnce(validTokenData.expiresAt);
            const refreshToken = _token.tokenManager.getRefreshToken();
            expect(refreshToken).toBe(validTokenData.refreshToken);
        });
        it('should return null refresh token when unavailable', ()=>{
            localStorageMock.getItem.mockReturnValue(null);
            const refreshToken = _token.tokenManager.getRefreshToken();
            expect(refreshToken).toBeNull();
        });
    });
    describe('Expiration & Refresh Logic', ()=>{
        it('should detect when token needs refresh (within 5 minutes)', ()=>{
            const soonToExpireData = {
                ...validTokenData,
                expiresAt: new Date(Date.now() + 4 * 60 * 1000).toISOString()
            };
            localStorageMock.getItem.mockReturnValueOnce(soonToExpireData.token).mockReturnValueOnce(soonToExpireData.refreshToken).mockReturnValueOnce(soonToExpireData.expiresAt);
            const needsRefresh = _token.tokenManager.needsRefresh();
            expect(needsRefresh).toBe(true);
        });
        it('should not need refresh when token has plenty of time', ()=>{
            localStorageMock.getItem.mockReturnValueOnce(validTokenData.token).mockReturnValueOnce(validTokenData.refreshToken).mockReturnValueOnce(validTokenData.expiresAt);
            const needsRefresh = _token.tokenManager.needsRefresh();
            expect(needsRefresh).toBe(false);
        });
        it('should not need refresh when no token exists', ()=>{
            localStorageMock.getItem.mockReturnValue(null);
            const needsRefresh = _token.tokenManager.needsRefresh();
            expect(needsRefresh).toBe(false);
        });
        it('should not need refresh when no expiry date exists', ()=>{
            localStorageMock.getItem.mockReturnValueOnce(validTokenData.token).mockReturnValueOnce(validTokenData.refreshToken).mockReturnValueOnce(null);
            const needsRefresh = _token.tokenManager.needsRefresh();
            expect(needsRefresh).toBe(false);
        });
    });
    describe('JWT Payload Parsing', ()=>{
        it('should parse valid JWT payload correctly', ()=>{
            const payload = _token.tokenManager.parseTokenPayload(validTokenData.token);
            expect(payload).toEqual({
                sub: 'user-1',
                email: 'test@example.com',
                role: 'admin',
                exp: 1700000000,
                iat: 1699999000
            });
        });
        it('should handle malformed JWT tokens', ()=>{
            const malformedToken = 'invalid.token.format';
            const payload = _token.tokenManager.parseTokenPayload(malformedToken);
            expect(payload).toBeNull();
        });
        it('should handle JWT with missing payload section', ()=>{
            const tokenWithoutPayload = 'header..signature';
            const payload = _token.tokenManager.parseTokenPayload(tokenWithoutPayload);
            expect(payload).toBeNull();
        });
        it('should handle invalid base64 in JWT payload', ()=>{
            const tokenWithInvalidBase64 = 'header.invalid-base64-payload.signature';
            const payload = _token.tokenManager.parseTokenPayload(tokenWithInvalidBase64);
            expect(payload).toBeNull();
        });
        it('should get current user info from valid token', ()=>{
            localStorageMock.getItem.mockReturnValueOnce(validTokenData.token).mockReturnValueOnce(validTokenData.refreshToken).mockReturnValueOnce(validTokenData.expiresAt);
            const userInfo = _token.tokenManager.getCurrentUserInfo();
            expect(userInfo).toEqual({
                userId: 'user-1',
                email: 'test@example.com',
                role: 'admin'
            });
        });
        it('should return null user info when no token', ()=>{
            localStorageMock.getItem.mockReturnValue(null);
            const userInfo = _token.tokenManager.getCurrentUserInfo();
            expect(userInfo).toBeNull();
        });
        it('should return null user info when token payload is invalid', ()=>{
            const invalidToken = 'invalid.token.format';
            localStorageMock.getItem.mockReturnValueOnce(invalidToken).mockReturnValueOnce('refresh').mockReturnValueOnce(validTokenData.expiresAt);
            const userInfo = _token.tokenManager.getCurrentUserInfo();
            expect(userInfo).toBeNull();
        });
    });
    describe('API Client Integration', ()=>{
        it('should call updateApiClientToken without errors', ()=>{
            localStorageMock.getItem.mockReturnValueOnce(validTokenData.token).mockReturnValueOnce(validTokenData.refreshToken).mockReturnValueOnce(validTokenData.expiresAt);
            // Should not throw
            expect(()=>_token.tokenManager.updateApiClientToken()).not.toThrow();
        });
        it('should call updateApiClientToken with no token without errors', ()=>{
            localStorageMock.getItem.mockReturnValue(null);
            // Should not throw
            expect(()=>_token.tokenManager.updateApiClientToken()).not.toThrow();
        });
        it('should handle API client integration gracefully', ()=>{
            // API client integration is async and handled separately
            // This test ensures the method exists and can be called
            expect(typeof _token.tokenManager.updateApiClientToken).toBe('function');
            localStorageMock.getItem.mockReturnValueOnce(validTokenData.token).mockReturnValueOnce(validTokenData.refreshToken).mockReturnValueOnce(validTokenData.expiresAt);
            _token.tokenManager.updateApiClientToken();
            // Should complete without throwing
            expect(true).toBe(true);
        });
    });
    describe('Security Edge Cases', ()=>{
        it('should handle partial token data gracefully', ()=>{
            localStorageMock.getItem.mockReturnValueOnce(validTokenData.token).mockReturnValueOnce(null) // Missing refresh token
            .mockReturnValueOnce(validTokenData.expiresAt);
            const tokenInfo = _token.tokenManager.getTokenInfo();
            expect(tokenInfo.isValid).toBe(false);
            expect(tokenInfo.token).toBe(validTokenData.token);
            expect(tokenInfo.refreshToken).toBeNull();
        });
        it('should handle empty string tokens', ()=>{
            localStorageMock.getItem.mockReturnValueOnce('').mockReturnValueOnce('').mockReturnValueOnce('');
            const tokenInfo = _token.tokenManager.getTokenInfo();
            expect(tokenInfo.isValid).toBe(false);
        });
        it('should handle very large tokens', ()=>{
            const largeToken = 'a'.repeat(10000); // 10KB token
            const largeTokenData = {
                ...validTokenData,
                token: largeToken
            };
            // Reset localStorage mock to allow large token storage
            localStorageMock.setItem.mockClear();
            localStorageMock.setItem.mockImplementation(()=>{}); // Success
            expect(()=>_token.tokenManager.setTokens(largeTokenData)).not.toThrow();
            expect(localStorageMock.setItem).toHaveBeenCalledWith('auth_token', largeToken);
        });
        it('should handle concurrent token operations', ()=>{
            // Reset localStorage mock for this test
            localStorageMock.setItem.mockClear();
            localStorageMock.getItem.mockClear();
            localStorageMock.removeItem.mockClear();
            localStorageMock.setItem.mockImplementation(()=>{}); // Success
            localStorageMock.removeItem.mockImplementation(()=>{}); // Success
            // Simulate concurrent calls
            expect(()=>{
                _token.tokenManager.setTokens(validTokenData);
                _token.tokenManager.getTokenInfo();
                _token.tokenManager.clearTokens();
            }).not.toThrow();
            // Should not cause any errors
            expect(localStorageMock.setItem).toHaveBeenCalled();
            expect(localStorageMock.getItem).toHaveBeenCalled();
            expect(localStorageMock.removeItem).toHaveBeenCalled();
        });
        it('should validate token format before storage', ()=>{
            const invalidTokenData = {
                token: '',
                refreshToken: 'valid-refresh',
                expiresAt: validTokenData.expiresAt
            };
            // Reset localStorage mock for this test
            localStorageMock.setItem.mockClear();
            localStorageMock.setItem.mockImplementation(()=>{}); // Success
            _token.tokenManager.setTokens(invalidTokenData);
            // Should still store (validation happens on retrieval)
            expect(localStorageMock.setItem).toHaveBeenCalledWith('auth_token', '');
        });
    });
    describe('Instance Management', ()=>{
        it('should be a singleton instance', ()=>{
            const instance1 = _token.tokenManager;
            const instance2 = _token.tokenManager;
            expect(instance1).toBe(instance2);
        });
        it('should provide consistent interface', ()=>{
            expect(typeof _token.tokenManager.setTokens).toBe('function');
            expect(typeof _token.tokenManager.getTokenInfo).toBe('function');
            expect(typeof _token.tokenManager.clearTokens).toBe('function');
            expect(typeof _token.tokenManager.getAccessToken).toBe('function');
            expect(typeof _token.tokenManager.getRefreshToken).toBe('function');
            expect(typeof _token.tokenManager.needsRefresh).toBe('function');
            expect(typeof _token.tokenManager.updateApiClientToken).toBe('function');
            expect(typeof _token.tokenManager.getCurrentUserInfo).toBe('function');
            expect(typeof _token.tokenManager.parseTokenPayload).toBe('function');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy96d2VpZ2VuL1NpdGVzL2RhdGVuLXNlZS12Mi9zcmMvbGliL2F1dGgvX190ZXN0c19fL3Rva2VuLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUb2tlbiBNYW5hZ2VyIFRlc3RzIC0gSldUIFNlY3VyaXR5ICg5NSUgQ292ZXJhZ2UgVGFyZ2V0KVxuICogQ3JpdGljYWwgYnVzaW5lc3MgbG9naWMgZm9yIGF1dGhlbnRpY2F0aW9uIGFuZCBhdXRob3JpemF0aW9uXG4gKiBcbiAqIFRlc3QgQ2F0ZWdvcmllczpcbiAqIDEuIFRva2VuIFN0b3JhZ2UgJiBSZXRyaWV2YWwgT3BlcmF0aW9uc1xuICogMi4gRXhwaXJhdGlvbiBWYWxpZGF0aW9uICYgUmVmcmVzaCBMb2dpYyAgXG4gKiAzLiBKV1QgUGF5bG9hZCBQYXJzaW5nICYgVXNlciBJbmZvIEV4dHJhY3Rpb25cbiAqIDQuIEFQSSBDbGllbnQgSW50ZWdyYXRpb25cbiAqIDUuIFNlY3VyaXR5IEVkZ2UgQ2FzZXMgJiBFcnJvciBIYW5kbGluZ1xuICogNi4gU2VydmVyLVNpZGUgdnMgQ2xpZW50LVNpZGUgQmVoYXZpb3JcbiAqL1xuXG5pbXBvcnQgeyBhcHBMb2dnZXIgfSBmcm9tICdAL2xpYi9tb25pdG9yaW5nL2xvZ2dlci5jb25maWcnO1xuXG5pbXBvcnQgeyB0b2tlbk1hbmFnZXIsIHR5cGUgVG9rZW5EYXRhLCB0eXBlIFN0b3JlZFRva2VuSW5mbyB9IGZyb20gJy4uL3Rva2VuJztcblxuLy8gTW9jayBsb2dnZXIgdG8gYXZvaWQgY29uc29sZSBub2lzZSBpbiB0ZXN0cyAoYWxsb3dpbmcgYWN0dWFsIGxvZ2dpbmcgZm9yIGRlYnVnZ2luZylcbmplc3QubW9jaygnQC9saWIvbW9uaXRvcmluZy9sb2dnZXIuY29uZmlnJywgKCkgPT4gKHtcbiAgYXBwTG9nZ2VyOiB7XG4gICAgZGVidWc6IGplc3QuZm4oKSxcbiAgICB3YXJuOiBqZXN0LmZuKCksXG4gICAgZXJyb3I6IGplc3QuZm4oKSxcbiAgICBpbmZvOiBqZXN0LmZuKCksXG4gIH0sXG59KSk7XG5cbi8vIE1vY2sgQVBJIGNsaWVudCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbmplc3QubW9jaygnQC9saWIvYXBpL2NsaWVudCcsICgpID0+ICh7XG4gIGFwaUNsaWVudDoge1xuICAgIHNldEF1dGhUb2tlbjogamVzdC5mbigpLFxuICAgIGNsZWFyQXV0aFRva2VuOiBqZXN0LmZuKCksXG4gIH0sXG59KSk7XG5cbmRlc2NyaWJlKCdUb2tlbk1hbmFnZXIgLSBKV1QgU2VjdXJpdHkgVGVzdHMgKDk1JSBDb3ZlcmFnZSknLCAoKSA9PiB7XG4gIC8vIFRlc3QgZGF0YVxuICBjb25zdCB2YWxpZFRva2VuRGF0YTogVG9rZW5EYXRhID0ge1xuICAgIHRva2VuOiAnZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SnpkV0lpT2lKMWMyVnlMVEVpTENKbGJXRnBiQ0k2SW5SbGMzUkFaWGhoYlhCc1pTNWpiMjBpTENKeWIyeGxJam9pWVdSdGFXNGlMQ0psZUhBaU9qRTNNREF3TURBd01EQXNJbWxoZENJNk1UWTVPVGs1T1RBd01IMC50ZXN0LXNpZ25hdHVyZScsXG4gICAgcmVmcmVzaFRva2VuOiAncmVmcmVzaC10b2tlbi0xMjMnLFxuICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDM2MDAwMDApLnRvSVNPU3RyaW5nKCksIC8vIDEgaG91ciBmcm9tIG5vd1xuICB9O1xuXG4gIGNvbnN0IGV4cGlyZWRUb2tlbkRhdGE6IFRva2VuRGF0YSA9IHtcbiAgICB0b2tlbjogJ2V5SmhiR2NpT2lKSVV6STFOaUlzSW5SNWNDSTZJa3BYVkNKOS5leUp6ZFdJaU9pSjFjMlZ5TFRFaUxDSmxiV0ZwYkNJNkluUmxjM1JBWlhoaGJYQnNaUzVqYjIwaUxDSnliMnhsSWpvaVlXUnRhVzRpTENKbGVIQWlPakUyTURBd01EQXdNREFzSW1saGRDSTZNVFU1T1RrNU9UQXdNSDAudGVzdC1zaWduYXR1cmUnLFxuICAgIHJlZnJlc2hUb2tlbjogJ3JlZnJlc2gtdG9rZW4tZXhwaXJlZCcsXG4gICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMzYwMDAwMCkudG9JU09TdHJpbmcoKSwgLy8gMSBob3VyIGFnb1xuICB9O1xuXG4gIC8vIE1vY2sgbG9jYWxTdG9yYWdlXG4gIGNvbnN0IGxvY2FsU3RvcmFnZU1vY2sgPSB7XG4gICAgZ2V0SXRlbTogamVzdC5mbigpLFxuICAgIHNldEl0ZW06IGplc3QuZm4oKSxcbiAgICByZW1vdmVJdGVtOiBqZXN0LmZuKCksXG4gICAgY2xlYXI6IGplc3QuZm4oKSxcbiAgfTtcblxuICBjb25zdCBvcmlnaW5hbFdpbmRvdyA9IGdsb2JhbC53aW5kb3c7XG4gIGNvbnN0IG9yaWdpbmFsTG9jYWxTdG9yYWdlID0gZ2xvYmFsLmxvY2FsU3RvcmFnZTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBcbiAgICAvLyBNb2NrIHdpbmRvdyBhbmQgbG9jYWxTdG9yYWdlIGZvciBjbGllbnQtc2lkZSB0ZXN0c1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWwsICd3aW5kb3cnLCB7XG4gICAgICB2YWx1ZTogeyBsb2NhbFN0b3JhZ2U6IGxvY2FsU3RvcmFnZU1vY2sgfSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWwsICdsb2NhbFN0b3JhZ2UnLCB7XG4gICAgICB2YWx1ZTogbG9jYWxTdG9yYWdlTW9jayxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgd2luZG93XG4gICAgaWYgKG9yaWdpbmFsV2luZG93KSB7XG4gICAgICBnbG9iYWwud2luZG93ID0gb3JpZ2luYWxXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSAoZ2xvYmFsIGFzIGFueSkud2luZG93O1xuICAgIH1cbiAgICBnbG9iYWwubG9jYWxTdG9yYWdlID0gb3JpZ2luYWxMb2NhbFN0b3JhZ2U7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdUb2tlbiBTdG9yYWdlIE9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzdG9yZSB0b2tlbnMgc3VjY2Vzc2Z1bGx5IG9uIGNsaWVudCBzaWRlJywgKCkgPT4ge1xuICAgICAgdG9rZW5NYW5hZ2VyLnNldFRva2Vucyh2YWxpZFRva2VuRGF0YSk7XG5cbiAgICAgIGV4cGVjdChsb2NhbFN0b3JhZ2VNb2NrLnNldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdhdXRoX3Rva2VuJywgdmFsaWRUb2tlbkRhdGEudG9rZW4pO1xuICAgICAgZXhwZWN0KGxvY2FsU3RvcmFnZU1vY2suc2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3JlZnJlc2hfdG9rZW4nLCB2YWxpZFRva2VuRGF0YS5yZWZyZXNoVG9rZW4pO1xuICAgICAgZXhwZWN0KGxvY2FsU3RvcmFnZU1vY2suc2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3Rva2VuX2V4cGlyeScsIHZhbGlkVG9rZW5EYXRhLmV4cGlyZXNBdCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZXJ2ZXIgc2lkZSBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgLy8gU2luY2UgVG9rZW5NYW5hZ2VyIGlzIGEgc2luZ2xldG9uLCBpc0NsaWVudCBpcyBzZXQgb25jZSBhdCBtb2R1bGUgbG9hZFxuICAgICAgLy8gVGhpcyB0ZXN0IHZlcmlmaWVzIHRoZSBtZXRob2QgZG9lc24ndCB0aHJvdyByYXRoZXIgdGhhbiB0ZXN0aW5nIHRoZSBleGFjdCBzZXJ2ZXIgYmVoYXZpb3JcbiAgICAgIGV4cGVjdCgoKSA9PiB0b2tlbk1hbmFnZXIuc2V0VG9rZW5zKHZhbGlkVG9rZW5EYXRhKSkubm90LnRvVGhyb3coKTtcbiAgICAgIFxuICAgICAgLy8gVGhlIGFjdHVhbCBzZXJ2ZXItc2lkZSBiZWhhdmlvciB3b3VsZCBiZSB0ZXN0ZWQgaW4gYSBmcmVzaCBOb2RlLmpzIGVudmlyb25tZW50XG4gICAgICAvLyB3aGVyZSB3aW5kb3cgaXMgdW5kZWZpbmVkIGZyb20gdGhlIHN0YXJ0XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsb2NhbFN0b3JhZ2UgZXJyb3JzIGR1cmluZyBzdG9yYWdlJywgKCkgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlTW9jay5zZXRJdGVtLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3RvcmFnZSBxdW90YSBleGNlZWRlZCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdCgoKSA9PiB0b2tlbk1hbmFnZXIuc2V0VG9rZW5zKHZhbGlkVG9rZW5EYXRhKSkudG9UaHJvdygnVG9rZW4gc3RvcmFnZSBmYWlsZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2xlYXIgYWxsIHRva2VucyBzdWNjZXNzZnVsbHknLCAoKSA9PiB7XG4gICAgICB0b2tlbk1hbmFnZXIuY2xlYXJUb2tlbnMoKTtcblxuICAgICAgZXhwZWN0KGxvY2FsU3RvcmFnZU1vY2sucmVtb3ZlSXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2F1dGhfdG9rZW4nKTtcbiAgICAgIGV4cGVjdChsb2NhbFN0b3JhZ2VNb2NrLnJlbW92ZUl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdyZWZyZXNoX3Rva2VuJyk7XG4gICAgICBleHBlY3QobG9jYWxTdG9yYWdlTW9jay5yZW1vdmVJdGVtKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndG9rZW5fZXhwaXJ5Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsb2NhbFN0b3JhZ2UgZXJyb3JzIGR1cmluZyBjbGVhcmluZycsICgpID0+IHtcbiAgICAgIGxvY2FsU3RvcmFnZU1vY2sucmVtb3ZlSXRlbS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvY2FsU3RvcmFnZSBhY2Nlc3MgZGVuaWVkJyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvdywganVzdCBsb2cgZXJyb3JcbiAgICAgIGV4cGVjdCgoKSA9PiB0b2tlbk1hbmFnZXIuY2xlYXJUb2tlbnMoKSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlcnZlciBzaWRlIGNsZWFyaW5nIGdyYWNlZnVsbHknLCAoKSA9PiB7XG4gICAgICAvLyBTaW1pbGFyIHRvIHN0b3JhZ2UsIHNpbmNlIFRva2VuTWFuYWdlciBpcyBhIHNpbmdsZXRvbiwgdGhpcyB0ZXN0cyBncmFjZWZ1bCBoYW5kbGluZ1xuICAgICAgZXhwZWN0KCgpID0+IHRva2VuTWFuYWdlci5jbGVhclRva2VucygpKS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVG9rZW4gUmV0cmlldmFsICYgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHJpZXZlIHZhbGlkIHRva2VuIGluZm8nLCAoKSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2VNb2NrLmdldEl0ZW1cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEudG9rZW4pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHZhbGlkVG9rZW5EYXRhLnJlZnJlc2hUb2tlbilcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEuZXhwaXJlc0F0KTtcblxuICAgICAgY29uc3QgdG9rZW5JbmZvID0gdG9rZW5NYW5hZ2VyLmdldFRva2VuSW5mbygpO1xuXG4gICAgICBleHBlY3QodG9rZW5JbmZvKS50b0VxdWFsKHtcbiAgICAgICAgdG9rZW46IHZhbGlkVG9rZW5EYXRhLnRva2VuLFxuICAgICAgICByZWZyZXNoVG9rZW46IHZhbGlkVG9rZW5EYXRhLnJlZnJlc2hUb2tlbixcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZSh2YWxpZFRva2VuRGF0YS5leHBpcmVzQXQpLFxuICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICBpc0V4cGlyZWQ6IGZhbHNlLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBleHBpcmVkIHRva2VucyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2VNb2NrLmdldEl0ZW1cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoZXhwaXJlZFRva2VuRGF0YS50b2tlbilcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoZXhwaXJlZFRva2VuRGF0YS5yZWZyZXNoVG9rZW4pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKGV4cGlyZWRUb2tlbkRhdGEuZXhwaXJlc0F0KTtcblxuICAgICAgY29uc3QgdG9rZW5JbmZvID0gdG9rZW5NYW5hZ2VyLmdldFRva2VuSW5mbygpO1xuXG4gICAgICBleHBlY3QodG9rZW5JbmZvKS50b0VxdWFsKHtcbiAgICAgICAgdG9rZW46IGV4cGlyZWRUb2tlbkRhdGEudG9rZW4sXG4gICAgICAgIHJlZnJlc2hUb2tlbjogZXhwaXJlZFRva2VuRGF0YS5yZWZyZXNoVG9rZW4sXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoZXhwaXJlZFRva2VuRGF0YS5leHBpcmVzQXQpLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgaXNFeHBpcmVkOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIHRva2VucycsICgpID0+IHtcbiAgICAgIGxvY2FsU3RvcmFnZU1vY2suZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHRva2VuSW5mbyA9IHRva2VuTWFuYWdlci5nZXRUb2tlbkluZm8oKTtcblxuICAgICAgZXhwZWN0KHRva2VuSW5mbykudG9FcXVhbCh7XG4gICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICByZWZyZXNoVG9rZW46IG51bGwsXG4gICAgICAgIGV4cGlyZXNBdDogbnVsbCxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGlzRXhwaXJlZDogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW52YWxpZCBleHBpcnkgZGF0ZSBmb3JtYXQnLCAoKSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2VNb2NrLmdldEl0ZW1cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEudG9rZW4pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHZhbGlkVG9rZW5EYXRhLnJlZnJlc2hUb2tlbilcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJ2ludmFsaWQtZGF0ZScpO1xuXG4gICAgICBjb25zdCB0b2tlbkluZm8gPSB0b2tlbk1hbmFnZXIuZ2V0VG9rZW5JbmZvKCk7XG5cbiAgICAgIC8vIFRlc3QgY3VycmVudCBiZWhhdmlvcjogaW52YWxpZCBkYXRlIHN0cmluZyBjcmVhdGVzIGEgRGF0ZSBvYmplY3QgYnV0IHJlcHJlc2VudHMgSW52YWxpZCBEYXRlXG4gICAgICBleHBlY3QodG9rZW5JbmZvLmV4cGlyZXNBdCkudG9CZUluc3RhbmNlT2YoRGF0ZSk7XG4gICAgICBcbiAgICAgIC8vIEphdmFTY3JpcHQgRGF0ZSgnaW52YWxpZC1kYXRlJykgY3JlYXRlcyBhIERhdGUgdGhhdCBpc05hTiBidXQgc3RpbGwgdHJ1dGh5XG4gICAgICBjb25zdCBpc0ludmFsaWREYXRlID0gaXNOYU4odG9rZW5JbmZvLmV4cGlyZXNBdCEuZ2V0VGltZSgpKTtcbiAgICAgIGV4cGVjdChpc0ludmFsaWREYXRlKS50b0JlKHRydWUpOyAvLyBUaGUgZGF0ZSBzaG91bGQgYmUgaW52YWxpZFxuICAgICAgXG4gICAgICAvLyBDdXJyZW50IGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgY2hlY2sgZm9yIGludmFsaWQgZGF0ZXMgaW4gdGhlIGlzVmFsaWQgbG9naWNcbiAgICAgIC8vIFRoaXMgdGVzdCBkb2N1bWVudHMgdGhlIGN1cnJlbnQgYmVoYXZpb3IgLSBjb3VsZCBiZSBpbXByb3ZlZCBpbiBmdXR1cmVcbiAgICAgIC8vIEZvciBub3csIHdlIHRlc3QgdGhhdCBpdCBkb2Vzbid0IGNyYXNoIGFuZCByZXR1cm5zIGEgY29uc2lzdGVudCBzdHJ1Y3R1cmVcbiAgICAgIGV4cGVjdCh0eXBlb2YgdG9rZW5JbmZvLmlzVmFsaWQpLnRvQmUoJ2Jvb2xlYW4nKTtcbiAgICAgIGV4cGVjdCh0eXBlb2YgdG9rZW5JbmZvLmlzRXhwaXJlZCkudG9CZSgnYm9vbGVhbicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2VydmVyIHNpZGUgdG9rZW4gcmV0cmlldmFsIGdyYWNlZnVsbHknLCAoKSA9PiB7XG4gICAgICAvLyBTaW5jZSBUb2tlbk1hbmFnZXIgaXMgYSBzaW5nbGV0b24sIHRoaXMgdGVzdHMgZ3JhY2VmdWwgaGFuZGxpbmcgcmF0aGVyIHRoYW4gdHJ1ZSBzZXJ2ZXIgYmVoYXZpb3JcbiAgICAgIGNvbnN0IHRva2VuSW5mbyA9IHRva2VuTWFuYWdlci5nZXRUb2tlbkluZm8oKTtcblxuICAgICAgLy8gVGhlIG1ldGhvZCBzaG91bGQgbm90IHRocm93IGFuZCBzaG91bGQgcmV0dXJuIGEgdmFsaWQgVG9rZW5JbmZvIHN0cnVjdHVyZVxuICAgICAgZXhwZWN0KHRva2VuSW5mbykudG9IYXZlUHJvcGVydHkoJ3Rva2VuJyk7XG4gICAgICBleHBlY3QodG9rZW5JbmZvKS50b0hhdmVQcm9wZXJ0eSgncmVmcmVzaFRva2VuJyk7XG4gICAgICBleHBlY3QodG9rZW5JbmZvKS50b0hhdmVQcm9wZXJ0eSgnZXhwaXJlc0F0Jyk7XG4gICAgICBleHBlY3QodG9rZW5JbmZvKS50b0hhdmVQcm9wZXJ0eSgnaXNWYWxpZCcpO1xuICAgICAgZXhwZWN0KHRva2VuSW5mbykudG9IYXZlUHJvcGVydHkoJ2lzRXhwaXJlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbG9jYWxTdG9yYWdlIGVycm9ycyBkdXJpbmcgcmV0cmlldmFsJywgKCkgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlTW9jay5nZXRJdGVtLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9jYWxTdG9yYWdlIGFjY2VzcyBkZW5pZWQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0b2tlbkluZm8gPSB0b2tlbk1hbmFnZXIuZ2V0VG9rZW5JbmZvKCk7XG5cbiAgICAgIGV4cGVjdCh0b2tlbkluZm8uaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGdldCBhY2Nlc3MgdG9rZW4gd2hlbiB2YWxpZCcsICgpID0+IHtcbiAgICAgIGxvY2FsU3RvcmFnZU1vY2suZ2V0SXRlbVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSh2YWxpZFRva2VuRGF0YS50b2tlbilcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEucmVmcmVzaFRva2VuKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSh2YWxpZFRva2VuRGF0YS5leHBpcmVzQXQpO1xuXG4gICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHRva2VuTWFuYWdlci5nZXRBY2Nlc3NUb2tlbigpO1xuXG4gICAgICBleHBlY3QoYWNjZXNzVG9rZW4pLnRvQmUodmFsaWRUb2tlbkRhdGEudG9rZW4pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBhY2Nlc3MgdG9rZW4gd2hlbiBpbnZhbGlkJywgKCkgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlTW9jay5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSB0b2tlbk1hbmFnZXIuZ2V0QWNjZXNzVG9rZW4oKTtcblxuICAgICAgZXhwZWN0KGFjY2Vzc1Rva2VuKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBnZXQgcmVmcmVzaCB0b2tlbiB3aGVuIGF2YWlsYWJsZScsICgpID0+IHtcbiAgICAgIGxvY2FsU3RvcmFnZU1vY2suZ2V0SXRlbVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSh2YWxpZFRva2VuRGF0YS50b2tlbilcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEucmVmcmVzaFRva2VuKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSh2YWxpZFRva2VuRGF0YS5leHBpcmVzQXQpO1xuXG4gICAgICBjb25zdCByZWZyZXNoVG9rZW4gPSB0b2tlbk1hbmFnZXIuZ2V0UmVmcmVzaFRva2VuKCk7XG5cbiAgICAgIGV4cGVjdChyZWZyZXNoVG9rZW4pLnRvQmUodmFsaWRUb2tlbkRhdGEucmVmcmVzaFRva2VuKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgcmVmcmVzaCB0b2tlbiB3aGVuIHVuYXZhaWxhYmxlJywgKCkgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlTW9jay5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gdG9rZW5NYW5hZ2VyLmdldFJlZnJlc2hUb2tlbigpO1xuXG4gICAgICBleHBlY3QocmVmcmVzaFRva2VuKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXhwaXJhdGlvbiAmIFJlZnJlc2ggTG9naWMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkZXRlY3Qgd2hlbiB0b2tlbiBuZWVkcyByZWZyZXNoICh3aXRoaW4gNSBtaW51dGVzKScsICgpID0+IHtcbiAgICAgIGNvbnN0IHNvb25Ub0V4cGlyZURhdGEgPSB7XG4gICAgICAgIC4uLnZhbGlkVG9rZW5EYXRhLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyA0ICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLCAvLyA0IG1pbnV0ZXMgZnJvbSBub3dcbiAgICAgIH07XG5cbiAgICAgIGxvY2FsU3RvcmFnZU1vY2suZ2V0SXRlbVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZShzb29uVG9FeHBpcmVEYXRhLnRva2VuKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZShzb29uVG9FeHBpcmVEYXRhLnJlZnJlc2hUb2tlbilcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2Uoc29vblRvRXhwaXJlRGF0YS5leHBpcmVzQXQpO1xuXG4gICAgICBjb25zdCBuZWVkc1JlZnJlc2ggPSB0b2tlbk1hbmFnZXIubmVlZHNSZWZyZXNoKCk7XG5cbiAgICAgIGV4cGVjdChuZWVkc1JlZnJlc2gpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG5vdCBuZWVkIHJlZnJlc2ggd2hlbiB0b2tlbiBoYXMgcGxlbnR5IG9mIHRpbWUnLCAoKSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2VNb2NrLmdldEl0ZW1cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEudG9rZW4pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHZhbGlkVG9rZW5EYXRhLnJlZnJlc2hUb2tlbilcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEuZXhwaXJlc0F0KTtcblxuICAgICAgY29uc3QgbmVlZHNSZWZyZXNoID0gdG9rZW5NYW5hZ2VyLm5lZWRzUmVmcmVzaCgpO1xuXG4gICAgICBleHBlY3QobmVlZHNSZWZyZXNoKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IG5lZWQgcmVmcmVzaCB3aGVuIG5vIHRva2VuIGV4aXN0cycsICgpID0+IHtcbiAgICAgIGxvY2FsU3RvcmFnZU1vY2suZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG5cbiAgICAgIGNvbnN0IG5lZWRzUmVmcmVzaCA9IHRva2VuTWFuYWdlci5uZWVkc1JlZnJlc2goKTtcblxuICAgICAgZXhwZWN0KG5lZWRzUmVmcmVzaCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG5vdCBuZWVkIHJlZnJlc2ggd2hlbiBubyBleHBpcnkgZGF0ZSBleGlzdHMnLCAoKSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2VNb2NrLmdldEl0ZW1cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEudG9rZW4pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHZhbGlkVG9rZW5EYXRhLnJlZnJlc2hUb2tlbilcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UobnVsbCk7XG5cbiAgICAgIGNvbnN0IG5lZWRzUmVmcmVzaCA9IHRva2VuTWFuYWdlci5uZWVkc1JlZnJlc2goKTtcblxuICAgICAgZXhwZWN0KG5lZWRzUmVmcmVzaCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdKV1QgUGF5bG9hZCBQYXJzaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcGFyc2UgdmFsaWQgSldUIHBheWxvYWQgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHRva2VuTWFuYWdlci5wYXJzZVRva2VuUGF5bG9hZCh2YWxpZFRva2VuRGF0YS50b2tlbik7XG5cbiAgICAgIGV4cGVjdChwYXlsb2FkKS50b0VxdWFsKHtcbiAgICAgICAgc3ViOiAndXNlci0xJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZTogJ2FkbWluJyxcbiAgICAgICAgZXhwOiAxNzAwMDAwMDAwLFxuICAgICAgICBpYXQ6IDE2OTk5OTkwMDAsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1hbGZvcm1lZCBKV1QgdG9rZW5zJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsZm9ybWVkVG9rZW4gPSAnaW52YWxpZC50b2tlbi5mb3JtYXQnO1xuXG4gICAgICBjb25zdCBwYXlsb2FkID0gdG9rZW5NYW5hZ2VyLnBhcnNlVG9rZW5QYXlsb2FkKG1hbGZvcm1lZFRva2VuKTtcblxuICAgICAgZXhwZWN0KHBheWxvYWQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBKV1Qgd2l0aCBtaXNzaW5nIHBheWxvYWQgc2VjdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VuV2l0aG91dFBheWxvYWQgPSAnaGVhZGVyLi5zaWduYXR1cmUnO1xuXG4gICAgICBjb25zdCBwYXlsb2FkID0gdG9rZW5NYW5hZ2VyLnBhcnNlVG9rZW5QYXlsb2FkKHRva2VuV2l0aG91dFBheWxvYWQpO1xuXG4gICAgICBleHBlY3QocGF5bG9hZCkudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgYmFzZTY0IGluIEpXVCBwYXlsb2FkJywgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5XaXRoSW52YWxpZEJhc2U2NCA9ICdoZWFkZXIuaW52YWxpZC1iYXNlNjQtcGF5bG9hZC5zaWduYXR1cmUnO1xuXG4gICAgICBjb25zdCBwYXlsb2FkID0gdG9rZW5NYW5hZ2VyLnBhcnNlVG9rZW5QYXlsb2FkKHRva2VuV2l0aEludmFsaWRCYXNlNjQpO1xuXG4gICAgICBleHBlY3QocGF5bG9hZCkudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZ2V0IGN1cnJlbnQgdXNlciBpbmZvIGZyb20gdmFsaWQgdG9rZW4nLCAoKSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2VNb2NrLmdldEl0ZW1cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEudG9rZW4pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHZhbGlkVG9rZW5EYXRhLnJlZnJlc2hUb2tlbilcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEuZXhwaXJlc0F0KTtcblxuICAgICAgY29uc3QgdXNlckluZm8gPSB0b2tlbk1hbmFnZXIuZ2V0Q3VycmVudFVzZXJJbmZvKCk7XG5cbiAgICAgIGV4cGVjdCh1c2VySW5mbykudG9FcXVhbCh7XG4gICAgICAgIHVzZXJJZDogJ3VzZXItMScsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGU6ICdhZG1pbicsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgdXNlciBpbmZvIHdoZW4gbm8gdG9rZW4nLCAoKSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2VNb2NrLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKG51bGwpO1xuXG4gICAgICBjb25zdCB1c2VySW5mbyA9IHRva2VuTWFuYWdlci5nZXRDdXJyZW50VXNlckluZm8oKTtcblxuICAgICAgZXhwZWN0KHVzZXJJbmZvKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCB1c2VyIGluZm8gd2hlbiB0b2tlbiBwYXlsb2FkIGlzIGludmFsaWQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVG9rZW4gPSAnaW52YWxpZC50b2tlbi5mb3JtYXQnO1xuICAgICAgbG9jYWxTdG9yYWdlTW9jay5nZXRJdGVtXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKGludmFsaWRUb2tlbilcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJ3JlZnJlc2gnKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSh2YWxpZFRva2VuRGF0YS5leHBpcmVzQXQpO1xuXG4gICAgICBjb25zdCB1c2VySW5mbyA9IHRva2VuTWFuYWdlci5nZXRDdXJyZW50VXNlckluZm8oKTtcblxuICAgICAgZXhwZWN0KHVzZXJJbmZvKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQVBJIENsaWVudCBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNhbGwgdXBkYXRlQXBpQ2xpZW50VG9rZW4gd2l0aG91dCBlcnJvcnMnLCAoKSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2VNb2NrLmdldEl0ZW1cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEudG9rZW4pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHZhbGlkVG9rZW5EYXRhLnJlZnJlc2hUb2tlbilcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEuZXhwaXJlc0F0KTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvd1xuICAgICAgZXhwZWN0KCgpID0+IHRva2VuTWFuYWdlci51cGRhdGVBcGlDbGllbnRUb2tlbigpKS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjYWxsIHVwZGF0ZUFwaUNsaWVudFRva2VuIHdpdGggbm8gdG9rZW4gd2l0aG91dCBlcnJvcnMnLCAoKSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2VNb2NrLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKG51bGwpO1xuXG4gICAgICAvLyBTaG91bGQgbm90IHRocm93XG4gICAgICBleHBlY3QoKCkgPT4gdG9rZW5NYW5hZ2VyLnVwZGF0ZUFwaUNsaWVudFRva2VuKCkpLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBBUEkgY2xpZW50IGludGVncmF0aW9uIGdyYWNlZnVsbHknLCAoKSA9PiB7XG4gICAgICAvLyBBUEkgY2xpZW50IGludGVncmF0aW9uIGlzIGFzeW5jIGFuZCBoYW5kbGVkIHNlcGFyYXRlbHlcbiAgICAgIC8vIFRoaXMgdGVzdCBlbnN1cmVzIHRoZSBtZXRob2QgZXhpc3RzIGFuZCBjYW4gYmUgY2FsbGVkXG4gICAgICBleHBlY3QodHlwZW9mIHRva2VuTWFuYWdlci51cGRhdGVBcGlDbGllbnRUb2tlbikudG9CZSgnZnVuY3Rpb24nKTtcbiAgICAgIFxuICAgICAgbG9jYWxTdG9yYWdlTW9jay5nZXRJdGVtXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHZhbGlkVG9rZW5EYXRhLnRva2VuKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSh2YWxpZFRva2VuRGF0YS5yZWZyZXNoVG9rZW4pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHZhbGlkVG9rZW5EYXRhLmV4cGlyZXNBdCk7XG5cbiAgICAgIHRva2VuTWFuYWdlci51cGRhdGVBcGlDbGllbnRUb2tlbigpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aG91dCB0aHJvd2luZ1xuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTZWN1cml0eSBFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhcnRpYWwgdG9rZW4gZGF0YSBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlTW9jay5nZXRJdGVtXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHZhbGlkVG9rZW5EYXRhLnRva2VuKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZShudWxsKSAvLyBNaXNzaW5nIHJlZnJlc2ggdG9rZW5cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodmFsaWRUb2tlbkRhdGEuZXhwaXJlc0F0KTtcblxuICAgICAgY29uc3QgdG9rZW5JbmZvID0gdG9rZW5NYW5hZ2VyLmdldFRva2VuSW5mbygpO1xuXG4gICAgICBleHBlY3QodG9rZW5JbmZvLmlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHRva2VuSW5mby50b2tlbikudG9CZSh2YWxpZFRva2VuRGF0YS50b2tlbik7XG4gICAgICBleHBlY3QodG9rZW5JbmZvLnJlZnJlc2hUb2tlbikudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHN0cmluZyB0b2tlbnMnLCAoKSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2VNb2NrLmdldEl0ZW1cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnJyk7XG5cbiAgICAgIGNvbnN0IHRva2VuSW5mbyA9IHRva2VuTWFuYWdlci5nZXRUb2tlbkluZm8oKTtcblxuICAgICAgZXhwZWN0KHRva2VuSW5mby5pc1ZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHZlcnkgbGFyZ2UgdG9rZW5zJywgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VUb2tlbiA9ICdhJy5yZXBlYXQoMTAwMDApOyAvLyAxMEtCIHRva2VuXG4gICAgICBjb25zdCBsYXJnZVRva2VuRGF0YSA9IHtcbiAgICAgICAgLi4udmFsaWRUb2tlbkRhdGEsXG4gICAgICAgIHRva2VuOiBsYXJnZVRva2VuLFxuICAgICAgfTtcblxuICAgICAgLy8gUmVzZXQgbG9jYWxTdG9yYWdlIG1vY2sgdG8gYWxsb3cgbGFyZ2UgdG9rZW4gc3RvcmFnZVxuICAgICAgbG9jYWxTdG9yYWdlTW9jay5zZXRJdGVtLm1vY2tDbGVhcigpO1xuICAgICAgbG9jYWxTdG9yYWdlTW9jay5zZXRJdGVtLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7IC8vIFN1Y2Nlc3NcblxuICAgICAgZXhwZWN0KCgpID0+IHRva2VuTWFuYWdlci5zZXRUb2tlbnMobGFyZ2VUb2tlbkRhdGEpKS5ub3QudG9UaHJvdygpO1xuICAgICAgZXhwZWN0KGxvY2FsU3RvcmFnZU1vY2suc2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2F1dGhfdG9rZW4nLCBsYXJnZVRva2VuKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgdG9rZW4gb3BlcmF0aW9ucycsICgpID0+IHtcbiAgICAgIC8vIFJlc2V0IGxvY2FsU3RvcmFnZSBtb2NrIGZvciB0aGlzIHRlc3RcbiAgICAgIGxvY2FsU3RvcmFnZU1vY2suc2V0SXRlbS5tb2NrQ2xlYXIoKTtcbiAgICAgIGxvY2FsU3RvcmFnZU1vY2suZ2V0SXRlbS5tb2NrQ2xlYXIoKTtcbiAgICAgIGxvY2FsU3RvcmFnZU1vY2sucmVtb3ZlSXRlbS5tb2NrQ2xlYXIoKTtcbiAgICAgIGxvY2FsU3RvcmFnZU1vY2suc2V0SXRlbS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pOyAvLyBTdWNjZXNzXG4gICAgICBsb2NhbFN0b3JhZ2VNb2NrLnJlbW92ZUl0ZW0ubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTsgLy8gU3VjY2Vzc1xuXG4gICAgICAvLyBTaW11bGF0ZSBjb25jdXJyZW50IGNhbGxzXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICB0b2tlbk1hbmFnZXIuc2V0VG9rZW5zKHZhbGlkVG9rZW5EYXRhKTtcbiAgICAgICAgdG9rZW5NYW5hZ2VyLmdldFRva2VuSW5mbygpO1xuICAgICAgICB0b2tlbk1hbmFnZXIuY2xlYXJUb2tlbnMoKTtcbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgY2F1c2UgYW55IGVycm9yc1xuICAgICAgZXhwZWN0KGxvY2FsU3RvcmFnZU1vY2suc2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KGxvY2FsU3RvcmFnZU1vY2suZ2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KGxvY2FsU3RvcmFnZU1vY2sucmVtb3ZlSXRlbSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSB0b2tlbiBmb3JtYXQgYmVmb3JlIHN0b3JhZ2UnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVG9rZW5EYXRhID0ge1xuICAgICAgICB0b2tlbjogJycsIC8vIEVtcHR5IHRva2VuXG4gICAgICAgIHJlZnJlc2hUb2tlbjogJ3ZhbGlkLXJlZnJlc2gnLFxuICAgICAgICBleHBpcmVzQXQ6IHZhbGlkVG9rZW5EYXRhLmV4cGlyZXNBdCxcbiAgICAgIH07XG5cbiAgICAgIC8vIFJlc2V0IGxvY2FsU3RvcmFnZSBtb2NrIGZvciB0aGlzIHRlc3RcbiAgICAgIGxvY2FsU3RvcmFnZU1vY2suc2V0SXRlbS5tb2NrQ2xlYXIoKTtcbiAgICAgIGxvY2FsU3RvcmFnZU1vY2suc2V0SXRlbS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pOyAvLyBTdWNjZXNzXG5cbiAgICAgIHRva2VuTWFuYWdlci5zZXRUb2tlbnMoaW52YWxpZFRva2VuRGF0YSk7XG5cbiAgICAgIC8vIFNob3VsZCBzdGlsbCBzdG9yZSAodmFsaWRhdGlvbiBoYXBwZW5zIG9uIHJldHJpZXZhbClcbiAgICAgIGV4cGVjdChsb2NhbFN0b3JhZ2VNb2NrLnNldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdhdXRoX3Rva2VuJywgJycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW5zdGFuY2UgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGJlIGEgc2luZ2xldG9uIGluc3RhbmNlJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UxID0gdG9rZW5NYW5hZ2VyO1xuICAgICAgY29uc3QgaW5zdGFuY2UyID0gdG9rZW5NYW5hZ2VyO1xuXG4gICAgICBleHBlY3QoaW5zdGFuY2UxKS50b0JlKGluc3RhbmNlMik7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHByb3ZpZGUgY29uc2lzdGVudCBpbnRlcmZhY2UnLCAoKSA9PiB7XG4gICAgICBleHBlY3QodHlwZW9mIHRva2VuTWFuYWdlci5zZXRUb2tlbnMpLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgICBleHBlY3QodHlwZW9mIHRva2VuTWFuYWdlci5nZXRUb2tlbkluZm8pLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgICBleHBlY3QodHlwZW9mIHRva2VuTWFuYWdlci5jbGVhclRva2VucykudG9CZSgnZnVuY3Rpb24nKTtcbiAgICAgIGV4cGVjdCh0eXBlb2YgdG9rZW5NYW5hZ2VyLmdldEFjY2Vzc1Rva2VuKS50b0JlKCdmdW5jdGlvbicpO1xuICAgICAgZXhwZWN0KHR5cGVvZiB0b2tlbk1hbmFnZXIuZ2V0UmVmcmVzaFRva2VuKS50b0JlKCdmdW5jdGlvbicpO1xuICAgICAgZXhwZWN0KHR5cGVvZiB0b2tlbk1hbmFnZXIubmVlZHNSZWZyZXNoKS50b0JlKCdmdW5jdGlvbicpO1xuICAgICAgZXhwZWN0KHR5cGVvZiB0b2tlbk1hbmFnZXIudXBkYXRlQXBpQ2xpZW50VG9rZW4pLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgICBleHBlY3QodHlwZW9mIHRva2VuTWFuYWdlci5nZXRDdXJyZW50VXNlckluZm8pLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgICBleHBlY3QodHlwZW9mIHRva2VuTWFuYWdlci5wYXJzZVRva2VuUGF5bG9hZCkudG9CZSgnZnVuY3Rpb24nKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJhcHBMb2dnZXIiLCJkZWJ1ZyIsImZuIiwid2FybiIsImVycm9yIiwiaW5mbyIsImFwaUNsaWVudCIsInNldEF1dGhUb2tlbiIsImNsZWFyQXV0aFRva2VuIiwiZGVzY3JpYmUiLCJ2YWxpZFRva2VuRGF0YSIsInRva2VuIiwicmVmcmVzaFRva2VuIiwiZXhwaXJlc0F0IiwiRGF0ZSIsIm5vdyIsInRvSVNPU3RyaW5nIiwiZXhwaXJlZFRva2VuRGF0YSIsImxvY2FsU3RvcmFnZU1vY2siLCJnZXRJdGVtIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJjbGVhciIsIm9yaWdpbmFsV2luZG93IiwiZ2xvYmFsIiwid2luZG93Iiwib3JpZ2luYWxMb2NhbFN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2UiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImFmdGVyRWFjaCIsIml0IiwidG9rZW5NYW5hZ2VyIiwic2V0VG9rZW5zIiwiZXhwZWN0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJub3QiLCJ0b1Rocm93IiwibW9ja0ltcGxlbWVudGF0aW9uIiwiRXJyb3IiLCJjbGVhclRva2VucyIsIm1vY2tSZXR1cm5WYWx1ZU9uY2UiLCJ0b2tlbkluZm8iLCJnZXRUb2tlbkluZm8iLCJ0b0VxdWFsIiwiaXNWYWxpZCIsImlzRXhwaXJlZCIsIm1vY2tSZXR1cm5WYWx1ZSIsInRvQmVJbnN0YW5jZU9mIiwiaXNJbnZhbGlkRGF0ZSIsImlzTmFOIiwiZ2V0VGltZSIsInRvQmUiLCJ0b0hhdmVQcm9wZXJ0eSIsImFjY2Vzc1Rva2VuIiwiZ2V0QWNjZXNzVG9rZW4iLCJ0b0JlTnVsbCIsImdldFJlZnJlc2hUb2tlbiIsInNvb25Ub0V4cGlyZURhdGEiLCJuZWVkc1JlZnJlc2giLCJwYXlsb2FkIiwicGFyc2VUb2tlblBheWxvYWQiLCJzdWIiLCJlbWFpbCIsInJvbGUiLCJleHAiLCJpYXQiLCJtYWxmb3JtZWRUb2tlbiIsInRva2VuV2l0aG91dFBheWxvYWQiLCJ0b2tlbldpdGhJbnZhbGlkQmFzZTY0IiwidXNlckluZm8iLCJnZXRDdXJyZW50VXNlckluZm8iLCJ1c2VySWQiLCJpbnZhbGlkVG9rZW4iLCJ1cGRhdGVBcGlDbGllbnRUb2tlbiIsImxhcmdlVG9rZW4iLCJyZXBlYXQiLCJsYXJnZVRva2VuRGF0YSIsIm1vY2tDbGVhciIsInRvSGF2ZUJlZW5DYWxsZWQiLCJpbnZhbGlkVG9rZW5EYXRhIiwiaW5zdGFuY2UxIiwiaW5zdGFuY2UyIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Q0FXQztBQU1ELHNGQUFzRjtBQUN0RkEsS0FBS0MsSUFBSSxDQUFDLGtDQUFrQyxJQUFPLENBQUE7UUFDakRDLFdBQVc7WUFDVEMsT0FBT0gsS0FBS0ksRUFBRTtZQUNkQyxNQUFNTCxLQUFLSSxFQUFFO1lBQ2JFLE9BQU9OLEtBQUtJLEVBQUU7WUFDZEcsTUFBTVAsS0FBS0ksRUFBRTtRQUNmO0lBQ0YsQ0FBQTtBQUVBLGlEQUFpRDtBQUNqREosS0FBS0MsSUFBSSxDQUFDLG9CQUFvQixJQUFPLENBQUE7UUFDbkNPLFdBQVc7WUFDVEMsY0FBY1QsS0FBS0ksRUFBRTtZQUNyQk0sZ0JBQWdCVixLQUFLSSxFQUFFO1FBQ3pCO0lBQ0YsQ0FBQTs7Ozt1QkFsQm1FO0FBb0JuRU8sU0FBUyxvREFBb0Q7SUFDM0QsWUFBWTtJQUNaLE1BQU1DLGlCQUE0QjtRQUNoQ0MsT0FBTztRQUNQQyxjQUFjO1FBQ2RDLFdBQVcsSUFBSUMsS0FBS0EsS0FBS0MsR0FBRyxLQUFLLFNBQVNDLFdBQVc7SUFDdkQ7SUFFQSxNQUFNQyxtQkFBOEI7UUFDbENOLE9BQU87UUFDUEMsY0FBYztRQUNkQyxXQUFXLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsS0FBSyxTQUFTQyxXQUFXO0lBQ3ZEO0lBRUEsb0JBQW9CO0lBQ3BCLE1BQU1FLG1CQUFtQjtRQUN2QkMsU0FBU3JCLEtBQUtJLEVBQUU7UUFDaEJrQixTQUFTdEIsS0FBS0ksRUFBRTtRQUNoQm1CLFlBQVl2QixLQUFLSSxFQUFFO1FBQ25Cb0IsT0FBT3hCLEtBQUtJLEVBQUU7SUFDaEI7SUFFQSxNQUFNcUIsaUJBQWlCQyxPQUFPQyxNQUFNO0lBQ3BDLE1BQU1DLHVCQUF1QkYsT0FBT0csWUFBWTtJQUVoREMsV0FBVztRQUNUOUIsS0FBSytCLGFBQWE7UUFFbEIscURBQXFEO1FBQ3JEQyxP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