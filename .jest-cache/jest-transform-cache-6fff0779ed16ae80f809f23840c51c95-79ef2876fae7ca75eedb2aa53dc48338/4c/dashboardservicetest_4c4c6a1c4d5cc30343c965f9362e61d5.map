{"version":3,"sources":["/Users/zweigen/Sites/daten-see-v2/src/lib/api/__tests__/dashboard.service.test.ts"],"sourcesContent":["/**\n * Dashboard Service Error Handling Tests\n * 85% Coverage Target for Critical Business Logic\n * \n * Test Categories:\n * 1. Network & HTTP Error Handling\n * 2. API Client Integration Failures\n * 3. Response Validation & Malformed Data\n * 4. Authentication & Authorization Errors  \n * 5. Concurrent Operations & Race Conditions\n * 6. Resource Limits & Rate Limiting\n * 7. Widget Service Error Scenarios\n * 8. Input Validation & Boundary Conditions\n */\n\nimport { DashboardService, WidgetService } from '../dashboard';\nimport { apiClient } from '../index';\nimport type {\n  Dashboard,\n  DashboardWidget,\n  CreateDashboardRequest,\n  UpdateDashboardRequest,\n  CreateWidgetRequest,\n  UpdateWidgetRequest,\n  PaginatedResponse,\n} from '@/types';\n\n// Mock the API client\njest.mock('../index', () => ({\n  apiClient: {\n    get: jest.fn(),\n    post: jest.fn(),\n    put: jest.fn(),\n    delete: jest.fn(),\n    getPaginated: jest.fn(),\n  },\n  createQueryFunction: jest.fn((fn) => fn), // Pass through for testing\n}));\n\ndescribe('DashboardService - Error Handling Tests (85% Coverage)', () => {\n  // Test data\n  const mockDashboard: Dashboard = {\n    id: 'dash-1',\n    name: 'Test Dashboard',\n    description: 'Test dashboard description',\n    isPublic: false,\n    userId: 'user-1',\n    createdAt: '2024-01-01T00:00:00.000Z',\n    updatedAt: '2024-01-01T00:00:00.000Z',\n  };\n\n  const mockWidget: DashboardWidget = {\n    id: 'widget-1',\n    dashboardId: 'dash-1',\n    type: 'chart',\n    title: 'Test Widget',\n    position: { x: 0, y: 0, w: 6, h: 4 },\n    configuration: {},\n    createdAt: '2024-01-01T00:00:00.000Z',\n    updatedAt: '2024-01-01T00:00:00.000Z',\n  };\n\n  const mockApiClient = apiClient as jest.Mocked<typeof apiClient>;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('DashboardService - Network & HTTP Errors', () => {\n    it('should handle 404 Not Found errors', async () => {\n      const error = new Error('Dashboard not found');\n      error.name = 'HTTPError';\n      (error as any).status = 404;\n      \n      mockApiClient.get.mockRejectedValue(error);\n\n      await expect(DashboardService.getDashboard('non-existent'))\n        .rejects.toThrow('Dashboard not found');\n      \n      expect(mockApiClient.get).toHaveBeenCalledWith('/dashboards/non-existent');\n    });\n\n    it('should handle 500 Internal Server Error', async () => {\n      const error = new Error('Internal server error');\n      error.name = 'HTTPError';\n      (error as any).status = 500;\n      \n      mockApiClient.get.mockRejectedValue(error);\n\n      await expect(DashboardService.getDashboards())\n        .rejects.toThrow('Internal server error');\n    });\n\n    it('should handle 403 Forbidden errors', async () => {\n      const error = new Error('Access denied');\n      error.name = 'HTTPError';\n      (error as any).status = 403;\n      \n      mockApiClient.get.mockRejectedValue(error);\n\n      await expect(DashboardService.getDashboard('restricted-dash'))\n        .rejects.toThrow('Access denied');\n    });\n\n    it('should handle 401 Unauthorized errors', async () => {\n      const error = new Error('Authentication required');\n      error.name = 'HTTPError';\n      (error as any).status = 401;\n      \n      mockApiClient.get.mockRejectedValue(error);\n\n      await expect(DashboardService.getDashboards())\n        .rejects.toThrow('Authentication required');\n    });\n\n    it('should handle 429 Rate Limiting errors', async () => {\n      const error = new Error('Too many requests');\n      error.name = 'HTTPError';\n      (error as any).status = 429;\n      \n      mockApiClient.get.mockRejectedValue(error);\n\n      await expect(DashboardService.getDashboards())\n        .rejects.toThrow('Too many requests');\n    });\n\n    it('should handle network timeout errors', async () => {\n      const timeoutError = new Error('Request timeout');\n      timeoutError.name = 'TimeoutError';\n      \n      mockApiClient.get.mockRejectedValue(timeoutError);\n\n      await expect(DashboardService.getDashboard('dash-1'))\n        .rejects.toThrow('Request timeout');\n    });\n\n    it('should handle connection refused errors', async () => {\n      const connectionError = new Error('Connection refused');\n      connectionError.name = 'ConnectError';\n      \n      mockApiClient.get.mockRejectedValue(connectionError);\n\n      await expect(DashboardService.getDashboards())\n        .rejects.toThrow('Connection refused');\n    });\n\n    it('should handle DNS resolution errors', async () => {\n      const dnsError = new Error('DNS resolution failed');\n      dnsError.name = 'DNSError';\n      \n      mockApiClient.get.mockRejectedValue(dnsError);\n\n      await expect(DashboardService.getDashboards())\n        .rejects.toThrow('DNS resolution failed');\n    });\n  });\n\n  describe('DashboardService - Response Validation Errors', () => {\n    it('should handle malformed JSON responses', async () => {\n      const malformedError = new Error('Invalid JSON response');\n      malformedError.name = 'SyntaxError';\n      \n      mockApiClient.get.mockRejectedValue(malformedError);\n\n      await expect(DashboardService.getDashboard('dash-1'))\n        .rejects.toThrow('Invalid JSON response');\n    });\n\n    it('should handle missing required fields in response', async () => {\n      const incompleteData = { id: 'dash-1' }; // Missing required fields\n      \n      mockApiClient.get.mockResolvedValue(incompleteData);\n\n      // This should work but the data might not be complete\n      // The validation happens at the component level typically\n      const result = await DashboardService.getDashboard('dash-1');\n      expect(result).toEqual(incompleteData);\n    });\n\n    it('should handle null or undefined responses', async () => {\n      mockApiClient.get.mockResolvedValue(null);\n\n      const result = await DashboardService.getDashboard('dash-1');\n      expect(result).toBeNull();\n    });\n\n    it('should handle empty array responses for getDashboards', async () => {\n      mockApiClient.get.mockResolvedValue([]);\n\n      const result = await DashboardService.getDashboards();\n      expect(result).toEqual([]);\n    });\n\n    it('should handle unexpected response structure', async () => {\n      const unexpectedData = { \n        data: [mockDashboard], \n        meta: { count: 1 } \n      }; // Wrapped structure instead of direct array\n      \n      mockApiClient.get.mockResolvedValue(unexpectedData);\n\n      const result = await DashboardService.getDashboards();\n      expect(result).toEqual(unexpectedData);\n    });\n  });\n\n  describe('DashboardService - Create/Update/Delete Error Handling', () => {\n    it('should handle create errors with detailed API response', async () => {\n      const apiResponse = {\n        success: false,\n        message: 'Validation failed: Name is required',\n        errors: {\n          name: ['Name cannot be empty'],\n          description: ['Description too long']\n        }\n      };\n      \n      mockApiClient.post.mockResolvedValue(apiResponse);\n\n      const createRequest: CreateDashboardRequest = {\n        name: '',\n        description: 'test',\n        isPublic: false,\n      };\n\n      await expect(DashboardService.createDashboard(createRequest))\n        .rejects.toThrow('Validation failed: Name is required');\n    });\n\n    it('should handle create errors without message', async () => {\n      const apiResponse = {\n        success: false,\n        data: null\n      };\n      \n      mockApiClient.post.mockResolvedValue(apiResponse);\n\n      const createRequest: CreateDashboardRequest = {\n        name: 'Test',\n        description: 'test',\n        isPublic: false,\n      };\n\n      await expect(DashboardService.createDashboard(createRequest))\n        .rejects.toThrow('Failed to create dashboard');\n    });\n\n    it('should handle update errors for non-existent dashboard', async () => {\n      const apiResponse = {\n        success: false,\n        message: 'Dashboard not found',\n      };\n      \n      mockApiClient.put.mockResolvedValue(apiResponse);\n\n      const updateRequest: UpdateDashboardRequest = {\n        name: 'Updated Name',\n      };\n\n      await expect(DashboardService.updateDashboard('non-existent', updateRequest))\n        .rejects.toThrow('Dashboard not found');\n    });\n\n    it('should handle delete errors for protected dashboard', async () => {\n      const apiResponse = {\n        success: false,\n        message: 'Cannot delete dashboard with active widgets',\n      };\n      \n      mockApiClient.delete.mockResolvedValue(apiResponse);\n\n      await expect(DashboardService.deleteDashboard('protected-dash'))\n        .rejects.toThrow('Cannot delete dashboard with active widgets');\n    });\n\n    it('should handle duplicate dashboard errors', async () => {\n      const apiResponse = {\n        success: false,\n        message: 'Failed to duplicate dashboard: Source not found',\n      };\n      \n      mockApiClient.post.mockResolvedValue(apiResponse);\n\n      await expect(DashboardService.duplicateDashboard('non-existent'))\n        .rejects.toThrow('Failed to duplicate dashboard: Source not found');\n    });\n\n    it('should handle duplicate with custom title', async () => {\n      const apiResponse = {\n        success: true,\n        data: { ...mockDashboard, name: 'Custom Title Copy' }\n      };\n      \n      mockApiClient.post.mockResolvedValue(apiResponse);\n\n      const result = await DashboardService.duplicateDashboard('dash-1', 'Custom Title');\n      expect(result.name).toBe('Custom Title Copy');\n      expect(mockApiClient.post).toHaveBeenCalledWith(\n        '/dashboards/dash-1/duplicate',\n        { title: 'Custom Title' }\n      );\n    });\n  });\n\n  describe('DashboardService - Pagination Error Handling', () => {\n    it('should handle pagination errors', async () => {\n      const paginationError = new Error('Invalid page parameter');\n      \n      mockApiClient.getPaginated.mockRejectedValue(paginationError);\n\n      await expect(DashboardService.getDashboardsPaginated(-1, 20))\n        .rejects.toThrow('Invalid page parameter');\n    });\n\n    it('should handle pagination with workspace filter errors', async () => {\n      const workspaceError = new Error('Workspace not found');\n      \n      mockApiClient.getPaginated.mockRejectedValue(workspaceError);\n\n      await expect(DashboardService.getDashboardsPaginated(1, 20, 'invalid-workspace'))\n        .rejects.toThrow('Workspace not found');\n    });\n\n    it('should handle successful pagination with workspace', async () => {\n      const paginatedResponse: PaginatedResponse<Dashboard> = {\n        data: [mockDashboard],\n        pagination: {\n          page: 1,\n          limit: 20,\n          total: 1,\n          totalPages: 1,\n        }\n      };\n      \n      mockApiClient.getPaginated.mockResolvedValue(paginatedResponse);\n\n      const result = await DashboardService.getDashboardsPaginated(1, 20, 'workspace-1');\n      expect(result).toEqual(paginatedResponse);\n      expect(mockApiClient.getPaginated).toHaveBeenCalledWith(\n        '/dashboards?workspaceId=workspace-1',\n        1,\n        20\n      );\n    });\n  });\n\n  describe('WidgetService - Error Handling', () => {\n    it('should handle widget creation errors', async () => {\n      const apiResponse = {\n        success: false,\n        message: 'Invalid widget configuration',\n      };\n      \n      mockApiClient.post.mockResolvedValue(apiResponse);\n\n      const createRequest: CreateWidgetRequest = {\n        dashboardId: 'dash-1',\n        type: 'chart',\n        title: 'Test Widget',\n        position: { x: 0, y: 0, w: 6, h: 4 },\n        configuration: {},\n      };\n\n      await expect(WidgetService.createWidget(createRequest))\n        .rejects.toThrow('Invalid widget configuration');\n    });\n\n    it('should handle widget position update errors', async () => {\n      const apiResponse = {\n        success: false,\n        message: 'Position conflict detected',\n      };\n      \n      mockApiClient.put.mockResolvedValue(apiResponse);\n\n      const positions = [\n        { id: 'widget-1', position: { x: 0, y: 0, w: 6, h: 4 } },\n        { id: 'widget-2', position: { x: 0, y: 0, w: 6, h: 4 } }, // Overlapping position\n      ];\n\n      await expect(WidgetService.updateWidgetPositions('dash-1', positions))\n        .rejects.toThrow('Position conflict detected');\n    });\n\n    it('should handle widget not found errors', async () => {\n      const error = new Error('Widget not found');\n      error.name = 'HTTPError';\n      (error as any).status = 404;\n      \n      mockApiClient.get.mockRejectedValue(error);\n\n      await expect(WidgetService.getWidget('dash-1', 'non-existent'))\n        .rejects.toThrow('Widget not found');\n    });\n\n    it('should handle widget update authorization errors', async () => {\n      const apiResponse = {\n        success: false,\n        message: 'Insufficient permissions to update widget',\n      };\n      \n      mockApiClient.put.mockResolvedValue(apiResponse);\n\n      const updateRequest: UpdateWidgetRequest = {\n        title: 'Updated Widget',\n      };\n\n      await expect(WidgetService.updateWidget('dash-1', 'widget-1', updateRequest))\n        .rejects.toThrow('Insufficient permissions to update widget');\n    });\n\n    it('should handle widget deletion with dependencies', async () => {\n      const apiResponse = {\n        success: false,\n        message: 'Cannot delete widget: Referenced by other widgets',\n      };\n      \n      mockApiClient.delete.mockResolvedValue(apiResponse);\n\n      await expect(WidgetService.deleteWidget('dash-1', 'widget-with-deps'))\n        .rejects.toThrow('Cannot delete widget: Referenced by other widgets');\n    });\n\n    it('should handle bulk position update partial failures', async () => {\n      const successResponse = {\n        success: true,\n        data: [\n          { ...mockWidget, position: { x: 0, y: 0, w: 6, h: 4 } },\n          { ...mockWidget, id: 'widget-2', position: { x: 6, y: 0, w: 6, h: 4 } },\n        ]\n      };\n      \n      mockApiClient.put.mockResolvedValue(successResponse);\n\n      const positions = [\n        { id: 'widget-1', position: { x: 0, y: 0, w: 6, h: 4 } },\n        { id: 'widget-2', position: { x: 6, y: 0, w: 6, h: 4 } },\n      ];\n\n      const result = await WidgetService.updateWidgetPositions('dash-1', positions);\n      expect(result).toHaveLength(2);\n      expect(result[0].position).toEqual({ x: 0, y: 0, w: 6, h: 4 });\n    });\n  });\n\n  describe('Concurrent Operations & Race Conditions', () => {\n    it('should handle concurrent dashboard updates', async () => {\n      // First request succeeds\n      mockApiClient.put\n        .mockResolvedValueOnce({\n          success: true,\n          data: { ...mockDashboard, name: 'First Update' }\n        })\n        .mockResolvedValueOnce({\n          success: false,\n          message: 'Optimistic lock failure: Dashboard was updated by another user'\n        });\n\n      const updateRequest1: UpdateDashboardRequest = { name: 'First Update' };\n      const updateRequest2: UpdateDashboardRequest = { name: 'Second Update' };\n\n      // Start both operations\n      const update1 = DashboardService.updateDashboard('dash-1', updateRequest1);\n      const update2 = DashboardService.updateDashboard('dash-1', updateRequest2);\n\n      const result1 = await update1;\n      expect(result1.name).toBe('First Update');\n\n      await expect(update2).rejects.toThrow('Optimistic lock failure');\n    });\n\n    it('should handle concurrent widget creation', async () => {\n      mockApiClient.post\n        .mockResolvedValueOnce({\n          success: true,\n          data: { ...mockWidget, id: 'widget-1' }\n        })\n        .mockResolvedValueOnce({\n          success: false,\n          message: 'Position already occupied'\n        });\n\n      const createRequest: CreateWidgetRequest = {\n        dashboardId: 'dash-1',\n        type: 'chart',\n        title: 'Test Widget',\n        position: { x: 0, y: 0, w: 6, h: 4 },\n        configuration: {},\n      };\n\n      const create1 = WidgetService.createWidget(createRequest);\n      const create2 = WidgetService.createWidget(createRequest); // Same position\n\n      const result1 = await create1;\n      expect(result1.id).toBe('widget-1');\n\n      await expect(create2).rejects.toThrow('Position already occupied');\n    });\n  });\n\n  describe('Input Validation & Boundary Conditions', () => {\n    it('should handle empty dashboard name validation', async () => {\n      const apiResponse = {\n        success: false,\n        message: 'Dashboard name cannot be empty',\n      };\n      \n      mockApiClient.post.mockResolvedValue(apiResponse);\n\n      const createRequest: CreateDashboardRequest = {\n        name: '',\n        description: 'test',\n        isPublic: false,\n      };\n\n      await expect(DashboardService.createDashboard(createRequest))\n        .rejects.toThrow('Dashboard name cannot be empty');\n    });\n\n    it('should handle extremely long dashboard names', async () => {\n      const apiResponse = {\n        success: false,\n        message: 'Dashboard name too long (max 255 characters)',\n      };\n      \n      mockApiClient.post.mockResolvedValue(apiResponse);\n\n      const createRequest: CreateDashboardRequest = {\n        name: 'A'.repeat(300), // Exceeds limit\n        description: 'test',\n        isPublic: false,\n      };\n\n      await expect(DashboardService.createDashboard(createRequest))\n        .rejects.toThrow('Dashboard name too long (max 255 characters)');\n    });\n\n    it('should handle invalid widget position coordinates', async () => {\n      const apiResponse = {\n        success: false,\n        message: 'Invalid widget position: coordinates must be non-negative',\n      };\n      \n      mockApiClient.post.mockResolvedValue(apiResponse);\n\n      const createRequest: CreateWidgetRequest = {\n        dashboardId: 'dash-1',\n        type: 'chart',\n        title: 'Test Widget',\n        position: { x: -1, y: -1, w: 6, h: 4 }, // Invalid negative coordinates\n        configuration: {},\n      };\n\n      await expect(WidgetService.createWidget(createRequest))\n        .rejects.toThrow('Invalid widget position: coordinates must be non-negative');\n    });\n\n    it('should handle missing dashboard ID in widget operations', async () => {\n      const error = new Error('Dashboard ID is required');\n      \n      mockApiClient.get.mockRejectedValue(error);\n\n      await expect(WidgetService.getWidgets(''))\n        .rejects.toThrow('Dashboard ID is required');\n    });\n  });\n\n  describe('Edge Cases & Error Recovery', () => {\n    it('should handle API client returning undefined', async () => {\n      mockApiClient.get.mockResolvedValue(undefined);\n\n      const result = await DashboardService.getDashboards();\n      expect(result).toBeUndefined();\n    });\n\n    it('should handle workspace queries with special characters', async () => {\n      const specialWorkspaceId = 'workspace-with-special-chars!@#$%';\n      mockApiClient.get.mockResolvedValue([mockDashboard]);\n\n      const result = await DashboardService.getDashboards(specialWorkspaceId);\n      expect(result).toEqual([mockDashboard]);\n      expect(mockApiClient.get).toHaveBeenCalledWith(\n        `/dashboards?workspaceId=${specialWorkspaceId}`\n      );\n    });\n\n    it('should handle duplicate dashboard without custom title', async () => {\n      const apiResponse = {\n        success: true,\n        data: { ...mockDashboard, name: 'Test Dashboard Copy' }\n      };\n      \n      mockApiClient.post.mockResolvedValue(apiResponse);\n\n      const result = await DashboardService.duplicateDashboard('dash-1');\n      expect(result.name).toBe('Test Dashboard Copy');\n      expect(mockApiClient.post).toHaveBeenCalledWith(\n        '/dashboards/dash-1/duplicate',\n        {}\n      );\n    });\n\n    it('should handle widget service with empty position array', async () => {\n      const apiResponse = {\n        success: true,\n        data: []\n      };\n      \n      mockApiClient.put.mockResolvedValue(apiResponse);\n\n      const result = await WidgetService.updateWidgetPositions('dash-1', []);\n      expect(result).toEqual([]);\n    });\n  });\n});"],"names":["jest","mock","apiClient","get","fn","post","put","delete","getPaginated","createQueryFunction","describe","mockDashboard","id","name","description","isPublic","userId","createdAt","updatedAt","mockWidget","dashboardId","type","title","position","x","y","w","h","configuration","mockApiClient","beforeEach","clearAllMocks","it","error","Error","status","mockRejectedValue","expect","DashboardService","getDashboard","rejects","toThrow","toHaveBeenCalledWith","getDashboards","timeoutError","connectionError","dnsError","malformedError","incompleteData","mockResolvedValue","result","toEqual","toBeNull","unexpectedData","data","meta","count","apiResponse","success","message","errors","createRequest","createDashboard","updateRequest","updateDashboard","deleteDashboard","duplicateDashboard","toBe","paginationError","getDashboardsPaginated","workspaceError","paginatedResponse","pagination","page","limit","total","totalPages","WidgetService","createWidget","positions","updateWidgetPositions","getWidget","updateWidget","deleteWidget","successResponse","toHaveLength","mockResolvedValueOnce","updateRequest1","updateRequest2","update1","update2","result1","create1","create2","repeat","getWidgets","undefined","toBeUndefined","specialWorkspaceId"],"mappings":"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"}