{"version":3,"sources":["/Users/zweigen/Sites/daten-see-v2/src/lib/tanstack-query/__tests__/integration-safety.test.tsx"],"sourcesContent":["/**\n * TanStack Query Integration Safety Tests\n * Tests: Cache management, mutation safety, query configuration, error handling\n * \n * CRITICAL for AI Safety - ensures query state consistency and prevents data corruption\n */\n\nimport { QueryClient, QueryClientProvider, useQuery, useMutation } from '@tanstack/react-query';\nimport { renderHook, waitFor, act } from '@testing-library/react';\nimport React from 'react';\n\nimport { createOptimizedQueryClient, QUERY_CONFIG, queryKeys } from '../config';\n\n// Test wrapper with QueryClient\nconst createTestQueryClient = (): QueryClient => {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        retry: false, // Disable retries for testing\n        staleTime: 0,\n        gcTime: 0,\n      },\n      mutations: {\n        retry: false,\n      },\n    },\n  });\n};\n\nconst createWrapper = (queryClient: QueryClient): React.FC<{ children: React.ReactNode }> => {\n  return ({ children }: { children: React.ReactNode }): JSX.Element => (\n    <QueryClientProvider client={queryClient}>\n      {children}\n    </QueryClientProvider>\n  );\n};\n\ndescribe('TanStack Query Integration Safety Tests', (): void => {\n  let queryClient: QueryClient;\n\n  beforeEach((): void => {\n    queryClient = createTestQueryClient();\n    jest.clearAllMocks();\n  });\n\n  afterEach((): void => {\n    queryClient.clear();\n  });\n\n  describe('Query Configuration Safety', (): void => {\n    it('should use safe default configurations', (): void => {\n      const optimizedClient = createOptimizedQueryClient();\n      const defaultOptions = optimizedClient.getDefaultOptions();\n\n      // Verify retry limits prevent infinite loops\n      expect(typeof defaultOptions.queries?.retry).toBe('function');\n      const retryFn = defaultOptions.queries?.retry as (failureCount: number, error: Error) => boolean;\n      \n      // Should not retry 404s or 401s\n      expect(retryFn(1, { status: 404 } as unknown as Error)).toBe(false);\n      expect(retryFn(1, { status: 401 } as unknown as Error)).toBe(false);\n      \n      // Should retry other errors but limit attempts\n      expect(retryFn(1, new Error('Network error'))).toBe(true);\n      expect(retryFn(3, new Error('Network error'))).toBe(false);\n\n      // Verify stale time configurations are reasonable\n      expect(QUERY_CONFIG.CRITICAL.staleTime).toBe(30 * 1000); // 30 seconds\n      expect(QUERY_CONFIG.STATIC.staleTime).toBe(15 * 60 * 1000); // 15 minutes\n    });\n\n    it('should prevent dangerous query configurations', (): void => {\n      // Verify no infinite refetch intervals\n      Object.values(QUERY_CONFIG).forEach(config => {\n        if (config.refetchInterval) {\n          expect(config.refetchInterval).toBeGreaterThan(10000); // Minimum 10 seconds\n        }\n      });\n\n      // Verify garbage collection times prevent memory leaks\n      Object.values(QUERY_CONFIG).forEach(config => {\n        expect(config.gcTime).toBeGreaterThan(0);\n        expect(config.gcTime).toBeLessThan(2 * 60 * 60 * 1000); // Max 2 hours\n      });\n    });\n\n    it('should validate retry delay prevents overwhelming server', (): void => {\n      const optimizedClient = createOptimizedQueryClient();\n      const defaultOptions = optimizedClient.getDefaultOptions();\n      const retryDelay = defaultOptions.queries?.retryDelay as (attemptIndex: number) => number;\n\n      // Verify exponential backoff with reasonable limits\n      expect(retryDelay(0)).toBe(1000); // 1 second\n      expect(retryDelay(1)).toBe(2000); // 2 seconds\n      expect(retryDelay(2)).toBe(4000); // 4 seconds\n      expect(retryDelay(10)).toBe(30000); // Cap at 30 seconds\n    });\n  });\n\n  describe('Query State Management Safety', (): void => {\n    it('should handle basic query lifecycle correctly', async (): Promise<void> => {\n      const mockQueryFn = jest.fn().mockResolvedValue(['item1', 'item2']);\n      \n      const useTestQuery = (): any => useQuery({\n        queryKey: ['test'],\n        queryFn: mockQueryFn,\n      });\n\n      const { result } = renderHook(() => useTestQuery(), {\n        wrapper: createWrapper(queryClient),\n      });\n\n      // Initial state should be safe\n      expect(result.current.isLoading).toBe(true);\n      expect(result.current.data).toBeUndefined();\n      expect(result.current.error).toBe(null);\n\n      // Wait for data to load\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true);\n      });\n\n      // Verify final state\n      expect(result.current.data).toEqual(['item1', 'item2']);\n      expect(mockQueryFn).toHaveBeenCalledTimes(1);\n    });\n\n    it('should handle query errors gracefully', async (): Promise<void> => {\n      const mockError = new Error('Test error');\n      const mockQueryFn = jest.fn().mockRejectedValue(mockError);\n      \n      const useTestQuery = (): any => useQuery({\n        queryKey: ['test-error'],\n        queryFn: mockQueryFn,\n      });\n\n      const { result } = renderHook(() => useTestQuery(), {\n        wrapper: createWrapper(queryClient),\n      });\n\n      await waitFor(() => {\n        expect(result.current.isError).toBe(true);\n      });\n\n      // Verify error state is handled properly\n      expect(result.current.error).toEqual(mockError);\n      expect(result.current.data).toBeUndefined();\n    });\n\n    it('should handle enabled/disabled queries correctly', async (): Promise<void> => {\n      const mockQueryFn = jest.fn().mockResolvedValue('data');\n      \n      const useTestQuery = (enabled: boolean): any => useQuery({\n        queryKey: ['test-enabled'],\n        queryFn: mockQueryFn,\n        enabled,\n      });\n\n      const { result, rerender } = renderHook(\n        ({ enabled }) => useTestQuery(enabled),\n        {\n          wrapper: createWrapper(queryClient),\n          initialProps: { enabled: false },\n        }\n      );\n\n      // Query should not execute when disabled\n      expect(result.current.isLoading).toBe(false);\n      expect(result.current.fetchStatus).toBe('idle');\n      expect(mockQueryFn).not.toHaveBeenCalled();\n\n      // Enable query\n      rerender({ enabled: true });\n\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true);\n      });\n\n      expect(mockQueryFn).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('Mutation Safety', (): void => {\n    it('should handle mutations with proper error boundaries', async (): Promise<void> => {\n      const mockMutationFn = jest.fn().mockResolvedValue({ id: 'new-item', name: 'Created' });\n      \n      const useTestMutation = (): any => useMutation({\n        mutationFn: mockMutationFn,\n      });\n\n      const { result } = renderHook(() => useTestMutation(), {\n        wrapper: createWrapper(queryClient),\n      });\n\n      // Initial state should be safe\n      expect(result.current.isIdle).toBe(true);\n      expect(result.current.data).toBeUndefined();\n      expect(result.current.error).toBe(null);\n\n      // Execute mutation\n      await act(async () => {\n        result.current.mutate({ name: 'Test Item' });\n      });\n\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true);\n      });\n\n      expect(result.current.data).toEqual({ id: 'new-item', name: 'Created' });\n      expect(mockMutationFn).toHaveBeenCalledWith({ name: 'Test Item' });\n    });\n\n    it('should handle mutation errors without breaking', async (): Promise<void> => {\n      const mockError = new Error('Mutation failed');\n      const mockMutationFn = jest.fn().mockRejectedValue(mockError);\n      \n      const useTestMutation = (): any => useMutation({\n        mutationFn: mockMutationFn,\n      });\n\n      const { result } = renderHook(() => useTestMutation(), {\n        wrapper: createWrapper(queryClient),\n      });\n\n      await act(async () => {\n        result.current.mutate({ name: 'Test Item' });\n      });\n\n      await waitFor(() => {\n        expect(result.current.isError).toBe(true);\n      });\n\n      expect(result.current.error).toEqual(mockError);\n      expect(result.current.data).toBeUndefined();\n    });\n  });\n\n  describe('Cache Management Safety', (): void => {\n    it('should prevent memory leaks through proper cache cleanup', async (): Promise<void> => {\n      const initialQueries = queryClient.getQueryCache().getAll().length;\n\n      // Create query\n      const { result } = renderHook(\n        () => useQuery({\n          queryKey: ['memory-test'],\n          queryFn: () => Promise.resolve('data'),\n        }),\n        { wrapper: createWrapper(queryClient) }\n      );\n\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true);\n      });\n\n      const queriesAfterCreation = queryClient.getQueryCache().getAll().length;\n      expect(queriesAfterCreation).toBeGreaterThan(initialQueries);\n\n      // Clear cache and verify cleanup\n      queryClient.clear();\n      \n      const queriesAfterCleanup = queryClient.getQueryCache().getAll().length;\n      expect(queriesAfterCleanup).toBe(0);\n    });\n\n    it('should handle cache invalidation safely', async (): Promise<void> => {\n      const mockQueryFn = jest.fn().mockResolvedValue(['item1', 'item2']);\n      \n      const { result } = renderHook(\n        () => useQuery({\n          queryKey: ['invalidation-test'],\n          queryFn: mockQueryFn,\n        }),\n        { wrapper: createWrapper(queryClient) }\n      );\n\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true);\n      });\n\n      expect(mockQueryFn).toHaveBeenCalledTimes(1);\n\n      // Invalidate query\n      await act(async () => {\n        queryClient.invalidateQueries({ queryKey: ['invalidation-test'] });\n      });\n\n      await waitFor(() => {\n        expect(mockQueryFn).toHaveBeenCalledTimes(2);\n      });\n    });\n  });\n\n  describe('Query Key Safety', (): void => {\n    it('should use consistent query keys', (): void => {\n      // Verify query keys are deterministic\n      const dashboardId = 'test-id';\n      \n      const listKey1 = queryKeys.dashboardsList();\n      const listKey2 = queryKeys.dashboardsList();\n      expect(listKey1).toEqual(listKey2);\n      \n      const detailKey1 = queryKeys.dashboard(dashboardId);\n      const detailKey2 = queryKeys.dashboard(dashboardId);\n      expect(detailKey1).toEqual(detailKey2);\n      \n      // Verify different IDs create different keys\n      const detailKey3 = queryKeys.dashboard('different-id');\n      expect(detailKey1).not.toEqual(detailKey3);\n    });\n\n    it('should prevent query key conflicts', (): void => {\n      // Verify query key structure prevents conflicts\n      const authKey = queryKeys.authUser();\n      const dashboardKey = queryKeys.dashboardsList();\n      \n      expect(authKey[0]).not.toBe(dashboardKey[0]);\n      expect(authKey.join('-')).not.toBe(dashboardKey.join('-'));\n    });\n  });\n\n  describe('Error Recovery Safety', (): void => {\n    it('should recover from network errors', async (): Promise<void> => {\n      let shouldFail = true;\n      const mockQueryFn = jest.fn().mockImplementation(() => {\n        if (shouldFail) {\n          return Promise.reject(new Error('Network error'));\n        }\n        return Promise.resolve('success');\n      });\n      \n      const { result } = renderHook(\n        () => useQuery({\n          queryKey: ['recovery-test'],\n          queryFn: mockQueryFn,\n        }),\n        { wrapper: createWrapper(queryClient) }\n      );\n\n      // Wait for initial error\n      await waitFor(() => {\n        expect(result.current.isError).toBe(true);\n      });\n\n      // Fix the \"network\" and retry\n      shouldFail = false;\n      \n      await act(async () => {\n        result.current.refetch();\n      });\n\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true);\n      });\n\n      expect(result.current.data).toBe('success');\n    });\n\n    it('should maintain state consistency during errors', async (): Promise<void> => {\n      const mockQueryFn = jest.fn()\n        .mockResolvedValueOnce('initial-data')\n        .mockRejectedValueOnce(new Error('Update failed'));\n      \n      const { result } = renderHook(\n        () => useQuery({\n          queryKey: ['consistency-test'],\n          queryFn: mockQueryFn,\n        }),\n        { wrapper: createWrapper(queryClient) }\n      );\n\n      // Wait for initial success\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true);\n      });\n\n      const initialData = result.current.data;\n\n      // Trigger refetch that will fail\n      await act(async () => {\n        result.current.refetch();\n      });\n\n      await waitFor(() => {\n        expect(result.current.isError).toBe(true);\n      });\n\n      // Previous data should still be available\n      expect(result.current.data).toBe(initialData);\n    });\n  });\n});"],"names":["createTestQueryClient","QueryClient","defaultOptions","queries","retry","staleTime","gcTime","mutations","createWrapper","queryClient","children","QueryClientProvider","client","describe","beforeEach","jest","clearAllMocks","afterEach","clear","it","optimizedClient","createOptimizedQueryClient","getDefaultOptions","expect","toBe","retryFn","status","Error","QUERY_CONFIG","CRITICAL","STATIC","Object","values","forEach","config","refetchInterval","toBeGreaterThan","toBeLessThan","retryDelay","mockQueryFn","fn","mockResolvedValue","useTestQuery","useQuery","queryKey","queryFn","result","renderHook","wrapper","current","isLoading","data","toBeUndefined","error","waitFor","isSuccess","toEqual","toHaveBeenCalledTimes","mockError","mockRejectedValue","isError","enabled","rerender","initialProps","fetchStatus","not","toHaveBeenCalled","mockMutationFn","id","name","useTestMutation","useMutation","mutationFn","isIdle","act","mutate","toHaveBeenCalledWith","initialQueries","getQueryCache","getAll","length","Promise","resolve","queriesAfterCreation","queriesAfterCleanup","invalidateQueries","dashboardId","listKey1","queryKeys","dashboardsList","listKey2","detailKey1","dashboard","detailKey2","detailKey3","authKey","authUser","dashboardKey","join","shouldFail","mockImplementation","reject","refetch","mockResolvedValueOnce","mockRejectedValueOnce","initialData"],"mappings":"AAAA;;;;;CAKC;;;;;4BAEuE;uBAC/B;+DACvB;wBAEkD;;;;;;AAEpE,gCAAgC;AAChC,MAAMA,wBAAwB;IAC5B,OAAO,IAAIC,uBAAW,CAAC;QACrBC,gBAAgB;YACdC,SAAS;gBACPC,OAAO;gBACPC,WAAW;gBACXC,QAAQ;YACV;YACAC,WAAW;gBACTH,OAAO;YACT;QACF;IACF;AACF;AAEA,MAAMI,gBAAgB,CAACC;IACrB,OAAO,CAAC,EAAEC,QAAQ,EAAiC,iBACjD,qBAACC,+BAAmB;YAACC,QAAQH;sBAC1BC;;AAGP;AAEAG,SAAS,2CAA2C;IAClD,IAAIJ;IAEJK,WAAW;QACTL,cAAcT;QACde,KAAKC,aAAa;IACpB;IAEAC,UAAU;QACRR,YAAYS,KAAK;IACnB;IAEAL,SAAS,8BAA8B;QACrCM,GAAG,0CAA0C;YAC3C,MAAMC,kBAAkBC,IAAAA,kCAA0B;YAClD,MAAMnB,iBAAiBkB,gBAAgBE,iBAAiB;YAExD,6CAA6C;YAC7CC,OAAO,OAAOrB,eAAeC,OAAO,EAAEC,OAAOoB,IAAI,CAAC;YAClD,MAAMC,UAAUvB,eAAeC,OAAO,EAAEC;YAExC,gCAAgC;YAChCmB,OAAOE,QAAQ,GAAG;gBAAEC,QAAQ;YAAI,IAAwBF,IAAI,CAAC;YAC7DD,OAAOE,QAAQ,GAAG;gBAAEC,QAAQ;YAAI,IAAwBF,IAAI,CAAC;YAE7D,+CAA+C;YAC/CD,OAAOE,QAAQ,GAAG,IAAIE,MAAM,mBAAmBH,IAAI,CAAC;YACpDD,OAAOE,QAAQ,GAAG,IAAIE,MAAM,mBAAmBH,IAAI,CAAC;YAEpD,kDAAkD;YAClDD,OAAOK,oBAAY,CAACC,QAAQ,CAACxB,SAAS,EAAEmB,IAAI,CAAC,KAAK,OAAO,aAAa;YACtED,OAAOK,oBAAY,CAACE,MAAM,CAACzB,SAAS,EAAEmB,IAAI,CAAC,KAAK,KAAK,OAAO,aAAa;QAC3E;QAEAL,GAAG,iDAAiD;YAClD,uCAAuC;YACvCY,OAAOC,MAAM,CAACJ,oBAAY,EAAEK,OAAO,CAACC,CAAAA;gBAClC,IAAIA,OAAOC,eAAe,EAAE;oBAC1BZ,OAAOW,OAAOC,eAAe,EAAEC,eAAe,CAAC,QAAQ,qBAAqB;gBAC9E;YACF;YAEA,uDAAuD;YACvDL,OAAOC,MAAM,CAACJ,oBAAY,EAAEK,OAAO,CAACC,CAAAA;gBAClCX,OAAOW,OAAO5B,MAAM,EAAE8B,eAAe,CAAC;gBACtCb,OAAOW,OAAO5B,MAAM,EAAE+B,YAAY,CAAC,IAAI,KAAK,KAAK,OAAO,cAAc;YACxE;QACF;QAEAlB,GAAG,4DAA4D;YAC7D,MAAMC,kBAAkBC,IAAAA,kCAA0B;YAClD,MAAMnB,iBAAiBkB,gBAAgBE,iBAAiB;YACxD,MAAMgB,aAAapC,eAAeC,OAAO,EAAEmC;YAE3C,oDAAoD;YACpDf,OAAOe,WAAW,IAAId,IAAI,CAAC,OAAO,WAAW;YAC7CD,OAAOe,WAAW,IAAId,IAAI,CAAC,OAAO,YAAY;YAC9CD,OAAOe,WAAW,IAAId,IAAI,CAAC,OAAO,YAAY;YAC9CD,OAAOe,WAAW,KAAKd,IAAI,CAAC,QAAQ,oBAAoB;QAC1D;IACF;IAEAX,SAAS,iCAAiC;QACxCM,GAAG,iDAAiD;YAClD,MAAMoB,cAAcxB,KAAKyB,EAAE,GAAGC,iBAAiB,CAAC;gBAAC;gBAAS;aAAQ;YAElE,MAAMC,eAAe,IAAWC,IAAAA,oBAAQ,EAAC;oBACvCC,UAAU;wBAAC;qBAAO;oBAClBC,SAASN;gBACX;YAEA,MAAM,EAAEO,MAAM,EAAE,GAAGC,IAAAA,iBAAU,EAAC,IAAML,gBAAgB;gBAClDM,SAASxC,cAAcC;YACzB;YAEA,+BAA+B;YAC/Bc,OAAOuB,OAAOG,OAAO,CAACC,SAAS,EAAE1B,IAAI,CAAC;YACtCD,OAAOuB,OAAOG,OAAO,CAACE,IAAI,EAAEC,aAAa;YACzC7B,OAAOuB,OAAOG,OAAO,CAACI,KAAK,EAAE7B,IAAI,CAAC;YAElC,wBAAwB;YACxB,MAAM8B,IAAAA,cAAO,EAAC;gBACZ/B,OAAOuB,OAAOG,OAAO,CAACM,SAAS,EAAE/B,IAAI,CAAC;YACxC;YAEA,qBAAqB;YACrBD,OAAOuB,OAAOG,OAAO,CAACE,IAAI,EAAEK,OAAO,CAAC;gBAAC;gBAAS;aAAQ;YACtDjC,OAAOgB,aAAakB,qBAAqB,CAAC;QAC5C;QAEAtC,GAAG,yCAAyC;YAC1C,MAAMuC,YAAY,IAAI/B,MAAM;YAC5B,MAAMY,cAAcxB,KAAKyB,EAAE,GAAGmB,iBAAiB,CAACD;YAEhD,MAAMhB,eAAe,IAAWC,IAAAA,oBAAQ,EAAC;oBACvCC,UAAU;wBAAC;qBAAa;oBACxBC,SAASN;gBACX;YAEA,MAAM,EAAEO,MAAM,EAAE,GAAGC,IAAAA,iBAAU,EAAC,IAAML,gBAAgB;gBAClDM,SAASxC,cAAcC;YACzB;YAEA,MAAM6C,IAAAA,cAAO,EAAC;gBACZ/B,OAAOuB,OAAOG,OAAO,CAACW,OAAO,EAAEpC,IAAI,CAAC;YACtC;YAEA,yCAAyC;YACzCD,OAAOuB,OAAOG,OAAO,CAACI,KAAK,EAAEG,OAAO,CAACE;YACrCnC,OAAOuB,OAAOG,OAAO,CAACE,IAAI,EAAEC,aAAa;QAC3C;QAEAjC,GAAG,oDAAoD;YACrD,MAAMoB,cAAcxB,KAAKyB,EAAE,GAAGC,iBAAiB,CAAC;YAEhD,MAAMC,eAAe,CAACmB,UAA0BlB,IAAAA,oBAAQ,EAAC;oBACvDC,UAAU;wBAAC;qBAAe;oBAC1BC,SAASN;oBACTsB;gBACF;YAEA,MAAM,EAAEf,MAAM,EAAEgB,QAAQ,EAAE,GAAGf,IAAAA,iBAAU,EACrC,CAAC,EAAEc,OAAO,EAAE,GAAKnB,aAAamB,UAC9B;gBACEb,SAASxC,cAAcC;gBACvBsD,cAAc;oBAAEF,SAAS;gBAAM;YACjC;YAGF,yCAAyC;YACzCtC,OAAOuB,OAAOG,OAAO,CAACC,SAAS,EAAE1B,IAAI,CAAC;YACtCD,OAAOuB,OAAOG,OAAO,CAACe,WAAW,EAAExC,IAAI,CAAC;YACxCD,OAAOgB,aAAa0B,GAAG,CAACC,gBAAgB;YAExC,eAAe;YACfJ,SAAS;gBAAED,SAAS;YAAK;YAEzB,MAAMP,IAAAA,cAAO,EAAC;gBACZ/B,OAAOuB,OAAOG,OAAO,CAACM,SAAS,EAAE/B,IAAI,CAAC;YACxC;YAEAD,OAAOgB,aAAakB,qBAAqB,CAAC;QAC5C;IACF;IAEA5C,SAAS,mBAAmB;QAC1BM,GAAG,wDAAwD;YACzD,MAAMgD,iBAAiBpD,KAAKyB,EAAE,GAAGC,iBAAiB,CAAC;gBAAE2B,IAAI;gBAAYC,MAAM;YAAU;YAErF,MAAMC,kBAAkB,IAAWC,IAAAA,uBAAW,EAAC;oBAC7CC,YAAYL;gBACd;YAEA,MAAM,EAAErB,MAAM,EAAE,GAAGC,IAAAA,iBAAU,EAAC,IAAMuB,mBAAmB;gBACrDtB,SAASxC,cAAcC;YACzB;YAEA,+BAA+B;YAC/Bc,OAAOuB,OAAOG,OAAO,CAACwB,MAAM,EAAEjD,IAAI,CAAC;YACnCD,OAAOuB,OAAOG,OAAO,CAACE,IAAI,EAAEC,aAAa;YACzC7B,OAAOuB,OAAOG,OAAO,CAACI,KAAK,EAAE7B,IAAI,CAAC;YAElC,mBAAmB;YACnB,MAAMkD,IAAAA,UAAG,EAAC;gBACR5B,OAAOG,OAAO,CAAC0B,MAAM,CAAC;oBAAEN,MAAM;gBAAY;YAC5C;YAEA,MAAMf,IAAAA,cAAO,EAAC;gBACZ/B,OAAOuB,OAAOG,OAAO,CAACM,SAAS,EAAE/B,IAAI,CAAC;YACxC;YAEAD,OAAOuB,OAAOG,OAAO,CAACE,IAAI,EAAEK,OAAO,CAAC;gBAAEY,IAAI;gBAAYC,MAAM;YAAU;YACtE9C,OAAO4C,gBAAgBS,oBAAoB,CAAC;gBAAEP,MAAM;YAAY;QAClE;QAEAlD,GAAG,kDAAkD;YACnD,MAAMuC,YAAY,IAAI/B,MAAM;YAC5B,MAAMwC,iBAAiBpD,KAAKyB,EAAE,GAAGmB,iBAAiB,CAACD;YAEnD,MAAMY,kBAAkB,IAAWC,IAAAA,uBAAW,EAAC;oBAC7CC,YAAYL;gBACd;YAEA,MAAM,EAAErB,MAAM,EAAE,GAAGC,IAAAA,iBAAU,EAAC,IAAMuB,mBAAmB;gBACrDtB,SAASxC,cAAcC;YACzB;YAEA,MAAMiE,IAAAA,UAAG,EAAC;gBACR5B,OAAOG,OAAO,CAAC0B,MAAM,CAAC;oBAAEN,MAAM;gBAAY;YAC5C;YAEA,MAAMf,IAAAA,cAAO,EAAC;gBACZ/B,OAAOuB,OAAOG,OAAO,CAACW,OAAO,EAAEpC,IAAI,CAAC;YACtC;YAEAD,OAAOuB,OAAOG,OAAO,CAACI,KAAK,EAAEG,OAAO,CAACE;YACrCnC,OAAOuB,OAAOG,OAAO,CAACE,IAAI,EAAEC,aAAa;QAC3C;IACF;IAEAvC,SAAS,2BAA2B;QAClCM,GAAG,4DAA4D;YAC7D,MAAM0D,iBAAiBpE,YAAYqE,aAAa,GAAGC,MAAM,GAAGC,MAAM;YAElE,eAAe;YACf,MAAM,EAAElC,MAAM,EAAE,GAAGC,IAAAA,iBAAU,EAC3B,IAAMJ,IAAAA,oBAAQ,EAAC;oBACbC,UAAU;wBAAC;qBAAc;oBACzBC,SAAS,IAAMoC,QAAQC,OAAO,CAAC;gBACjC,IACA;gBAAElC,SAASxC,cAAcC;YAAa;YAGxC,MAAM6C,IAAAA,cAAO,EAAC;gBACZ/B,OAAOuB,OAAOG,OAAO,CAACM,SAAS,EAAE/B,IAAI,CAAC;YACxC;YAEA,MAAM2D,uBAAuB1E,YAAYqE,aAAa,GAAGC,MAAM,GAAGC,MAAM;YACxEzD,OAAO4D,sBAAsB/C,eAAe,CAACyC;YAE7C,iCAAiC;YACjCpE,YAAYS,KAAK;YAEjB,MAAMkE,sBAAsB3E,YAAYqE,aAAa,GAAGC,MAAM,GAAGC,MAAM;YACvEzD,OAAO6D,qBAAqB5D,IAAI,CAAC;QACnC;QAEAL,GAAG,2CAA2C;YAC5C,MAAMoB,cAAcxB,KAAKyB,EAAE,GAAGC,iBAAiB,CAAC;gBAAC;gBAAS;aAAQ;YAElE,MAAM,EAAEK,MAAM,EAAE,GAAGC,IAAAA,iBAAU,EAC3B,IAAMJ,IAAAA,oBAAQ,EAAC;oBACbC,UAAU;wBAAC;qBAAoB;oBAC/BC,SAASN;gBACX,IACA;gBAAES,SAASxC,cAAcC;YAAa;YAGxC,MAAM6C,IAAAA,cAAO,EAAC;gBACZ/B,OAAOuB,OAAOG,OAAO,CAACM,SAAS,EAAE/B,IAAI,CAAC;YACxC;YAEAD,OAAOgB,aAAakB,qBAAqB,CAAC;YAE1C,mBAAmB;YACnB,MAAMiB,IAAAA,UAAG,EAAC;gBACRjE,YAAY4E,iBAAiB,CAAC;oBAAEzC,UAAU;wBAAC;qBAAoB;gBAAC;YAClE;YAEA,MAAMU,IAAAA,cAAO,EAAC;gBACZ/B,OAAOgB,aAAakB,qBAAqB,CAAC;YAC5C;QACF;IACF;IAEA5C,SAAS,oBAAoB;QAC3BM,GAAG,oCAAoC;YACrC,sCAAsC;YACtC,MAAMmE,cAAc;YAEpB,MAAMC,WAAWC,iBAAS,CAACC,cAAc;YACzC,MAAMC,WAAWF,iBAAS,CAACC,cAAc;YACzClE,OAAOgE,UAAU/B,OAAO,CAACkC;YAEzB,MAAMC,aAAaH,iBAAS,CAACI,SAAS,CAACN;YACvC,MAAMO,aAAaL,iBAAS,CAACI,SAAS,CAACN;YACvC/D,OAAOoE,YAAYnC,OAAO,CAACqC;YAE3B,6CAA6C;YAC7C,MAAMC,aAAaN,iBAAS,CAACI,SAAS,CAAC;YACvCrE,OAAOoE,YAAY1B,GAAG,CAACT,OAAO,CAACsC;QACjC;QAEA3E,GAAG,sCAAsC;YACvC,gDAAgD;YAChD,MAAM4E,UAAUP,iBAAS,CAACQ,QAAQ;YAClC,MAAMC,eAAeT,iBAAS,CAACC,cAAc;YAE7ClE,OAAOwE,OAAO,CAAC,EAAE,EAAE9B,GAAG,CAACzC,IAAI,CAACyE,YAAY,CAAC,EAAE;YAC3C1E,OAAOwE,QAAQG,IAAI,CAAC,MAAMjC,GAAG,CAACzC,IAAI,CAACyE,aAAaC,IAAI,CAAC;QACvD;IACF;IAEArF,SAAS,yBAAyB;QAChCM,GAAG,sCAAsC;YACvC,IAAIgF,aAAa;YACjB,MAAM5D,cAAcxB,KAAKyB,EAAE,GAAG4D,kBAAkB,CAAC;gBAC/C,IAAID,YAAY;oBACd,OAAOlB,QAAQoB,MAAM,CAAC,IAAI1E,MAAM;gBAClC;gBACA,OAAOsD,QAAQC,OAAO,CAAC;YACzB;YAEA,MAAM,EAAEpC,MAAM,EAAE,GAAGC,IAAAA,iBAAU,EAC3B,IAAMJ,IAAAA,oBAAQ,EAAC;oBACbC,UAAU;wBAAC;qBAAgB;oBAC3BC,SAASN;gBACX,IACA;gBAAES,SAASxC,cAAcC;YAAa;YAGxC,yBAAyB;YACzB,MAAM6C,IAAAA,cAAO,EAAC;gBACZ/B,OAAOuB,OAAOG,OAAO,CAACW,OAAO,EAAEpC,IAAI,CAAC;YACtC;YAEA,8BAA8B;YAC9B2E,aAAa;YAEb,MAAMzB,IAAAA,UAAG,EAAC;gBACR5B,OAAOG,OAAO,CAACqD,OAAO;YACxB;YAEA,MAAMhD,IAAAA,cAAO,EAAC;gBACZ/B,OAAOuB,OAAOG,OAAO,CAACM,SAAS,EAAE/B,IAAI,CAAC;YACxC;YAEAD,OAAOuB,OAAOG,OAAO,CAACE,IAAI,EAAE3B,IAAI,CAAC;QACnC;QAEAL,GAAG,mDAAmD;YACpD,MAAMoB,cAAcxB,KAAKyB,EAAE,GACxB+D,qBAAqB,CAAC,gBACtBC,qBAAqB,CAAC,IAAI7E,MAAM;YAEnC,MAAM,EAAEmB,MAAM,EAAE,GAAGC,IAAAA,iBAAU,EAC3B,IAAMJ,IAAAA,oBAAQ,EAAC;oBACbC,UAAU;wBAAC;qBAAmB;oBAC9BC,SAASN;gBACX,IACA;gBAAES,SAASxC,cAAcC;YAAa;YAGxC,2BAA2B;YAC3B,MAAM6C,IAAAA,cAAO,EAAC;gBACZ/B,OAAOuB,OAAOG,OAAO,CAACM,SAAS,EAAE/B,IAAI,CAAC;YACxC;YAEA,MAAMiF,cAAc3D,OAAOG,OAAO,CAACE,IAAI;YAEvC,iCAAiC;YACjC,MAAMuB,IAAAA,UAAG,EAAC;gBACR5B,OAAOG,OAAO,CAACqD,OAAO;YACxB;YAEA,MAAMhD,IAAAA,cAAO,EAAC;gBACZ/B,OAAOuB,OAAOG,OAAO,CAACW,OAAO,EAAEpC,IAAI,CAAC;YACtC;YAEA,0CAA0C;YAC1CD,OAAOuB,OAAOG,OAAO,CAACE,IAAI,EAAE3B,IAAI,CAACiF;QACnC;IACF;AACF"}